# Java基础



+ 编译 `.java` 为 `class` 文件：`javac Welcome.java`
+ 执行：`java Welcome`



## 数据类型和运算符

### 注释

```java
//单行注释
/*
多行注释
	*/
/**
 *文档注释
 */
```

1. 在类的方法中使用单行注释
2. 在类中使用文档注释

### 标识符

#### 标识符规则

1. 标识符必须是以字母、下划线、美元符号开头。
2. 标识符其他部分可以是字母、下划线、美元符、数字的任意组合。
3. Java标识符大小写敏感，且长度无限制。
4. 标识符不可以是Java关键字。

#### 标识符使用规范

1. 表示`类名`的标识符：每个单词的手写字母大写.Man,GoodMan
2. 表示方法和变量的标识符，第一个的单词小写，从第二个单词开始首字母大写。（也就是驼峰法命名）。

### Java中的关键字/保留字

| abstract   | assert  | boolean   | break     | byte       | case        |
| ---------- | ------- | --------- | --------- | ---------- | ----------- |
| catch      | char    | class     | const     | continue   | default     |
| do         | double  | else      | extends   | final      | finally     |
| float      | for     | goto      | if        | implements | import      |
| instanceof | int     | interface | long      | native     | new         |
| null       | package | private   | protected | public     | return      |
| short      | static  | strictfp  | super     | switch     | sychronized |
| this       | throw   | throws    | transient | try        | void        |
| volatile   | while   |           |           |            |             |

### 变量

#### 变量的本质

1. 变量的本质上就是代表一个“可操作的存储空间”，空间的位置是确定的，到那时里面放置什么值不确定。
2. 我们可以通过变量名来访问“对应的存储空间”，从而操作这个“存储空间”存储的值。

#### 变量的分类

| 类型                 | 声明位置           | 从属于      |                           声明周期                           |
| -------------------- | ------------------ | ----------- | :----------------------------------------------------------: |
| 局部变量             | 方法或语句块内部   | 方法/语句块 |   从声明位置开始，直到方法或语句块执行完毕，局部变量消失。   |
| 成员变量（实例变量） | 类内部，方法外部   | 对象        | 对象创建，成员变量也跟着创建，对象消失，成员变量也跟着消失。 |
| 静态变量（类变量）   | 类内部，static修饰 | 类          |      类被加载，静态变量就有效；类被卸载，静态变量消失。      |

### 常量

1. 常量通常是指一个固定的值。
2. 在Java中，主要是利用 `final` 来定义一个常量。常量一旦被初始化后不能在更改其值。
3. 常量声明格式 `final type varname = value;`

#### 变量和常量命名规范

1. 多有变量、方法、类名：见名知意
2. 类成员变量：首字母小写和驼峰法原则：monthSalary
3. 局部变量：首字母小写和驼峰原则
4. 常量：大写字母和下划线：MAX_VALUE
5. 类名：首字母大写和驼峰原则
6. 方法名：首字母小写和驼峰原则：run()

### 基本数据类型

+ Java的数据类型可分为两大类：基本数据类型（primitive data type）和引用数据类型（reference data type）。
+ 数值值 - byte、short、int、long、float、double
+ 字符型 - char
+ 布尔型 - boolean

![image-20200409115800605](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409115800605.png)

#### 整形变量/常量

| 类型  | 占用存储空间 | 表数范围                   |
| ----- | ------------ | -------------------------- |
| byte  | 1字节        | -2^7 ~ 2^7-1（-128 ~ 127） |
| short | 2字节        | -2^15 ~ 2^15 - 1（3万）    |
| int   | 4字节        | -2^31 ~ 2^31 - 1（21亿）   |
| long  | 8字节        | -2^63 ~ 2^63 - 1           |

1. 十进制整数：99，-500
2. 八进制整数，要求以0开头：015
3. 十六进制数，要求以0x或0X开头：0x15
4. 二进制数，要求以0b或0B开头：0b01110011
5. `long` 型常量声明时必须加`L` ，不然会别编译为int，还会报错： `long b = 5555555555555555555555L;`

#### 浮点型变量/常量

| 类型   | 占用存储空间 | 表数范围               |
| ------ | ------------ | ---------------------- |
| float  | 4字节        | -3.403E38 ~ 3.403E38   |
| double | 8字节        | -1.798E308 ~ 1.798E308 |

1. 带小数的数据在Java中称为浮点数。浮点数可分为 `float` 类型和 `double` 类型。
2. `float` 类型又被称为单精度类型，尾数可以精确到 `7` 位有效数字，在很多情况下， `float` 类型的精度很难满足需求。
3. `double` 类型的数值的精度约是 `float` 类型的两倍，又被称作双精度类型，绝大多数部分的应用程序都采用 `double` 类型，
4. 浮点数常量的默认类型也是 `double`。
5. `float` 类型的数值有一个后缀 `f` 或者 `F` ，没有后缀 `f/F`的浮点数被默认为 `double` 类型。
6. 浮点数 `float/double` 的数据不适合在不允许舍入误差的领域。
7. `BigDecimal` 类不产生舍入误差，实现了任意精度的浮点运算。 ` BigDecimal bd = BigDecimal.valueOf(1.0); ` 加减乘除使用的相关方法。
8. `BigInteger` 实现了任意精度的整数运算。

##### Java浮点类型常量有两种表示形式

+ 十进制数形式：3.14，314.0，0.314
+ 科学记数形式：314e2，314E2，314E-2

#### 字符型变量/常量

1. 字符型在Java中占2个字节。

2. 在Java职工使用单引号来表示字符常量：'A'

3. char 类型用来表示在 Unicode 编码表中的字符。

4. 转义字符

   | 转义符 | 含义            | Unicode值 |
   | ------ | --------------- | --------- |
   | \b     | 退格(backspace) | \u0008    |
   | \n     | 换行            | \u000a    |
   | \r     | 回车            | \u000d    |
   | \t     | 制表符(tab)     | \u0009    |
   | \\"    | 双引号          | \u0022    |
   | \\'    | 单引号          | \u0027    |
   | \\\    | 反斜杠          | \u005c    |

5. String的底层实现就是字符序列。

#### boolean 类型

1. `boolean` 类型有两个常量值： `true/false` 
2. `boolean` 在内存中占一位（不是一个字节）。
3. 不可以用`0/1`表示`true/false`

### 运算符

![image-20200409141113851](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409141113851.png)

#### 算数运算符

+ 二元运算符：+，-，*，/，%
+ 二元运算符顾名思义就是需要两个操作数才能完成运算的运算符
+ 一元运算符：++，--

##### 整数运算规则

1. 如果两个操作数有一个位 `long` ，则结果也为long。
2. 没有long时，结果位int。即使操作数全部为short，byte，结果也是int。

##### 浮点数运算规则

1. 如果两个操作数有一个为 `double` ，则结果为 `double`。
2. 只有两个数都是 `float` ，则结果才会为`float`

##### 取模运算规则

1. 操作数可以为浮点数，一般使用整数，结果是余数。
2. 余数的符号和左边的操作数相同：7%3=1，-7%3=-1，7%-3=1。

#### 赋值及其扩展赋值运算符

1. `+=,-=,*=,/=,%=`
2. 这些扩展运算符都是压缩了运算。

#### 关系运算符

![image-20200409142530815](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409142530815.png)

1. `=` 是赋值运算符
2. `==,!=` 是所有（基本和引用）数据类型都可以使用；但是在使用 `==` 的情况下一般都使用 `equals`
3. `>,>=,<,<=` 仅针对数值类型（byte/short/int/long，float/double，以及char）

#### 逻辑运算符

![image-20200409161634952](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409161634952.png)

1. 逻辑运算的操作数和运算结果都是boolean值。
2. 短路与和短路或采用短路的方式。从左到右计算，如果只通过运算操作符左边的操作数就能够确定该逻辑表达式，则不会继续计算操作符右边的操作数，提高效率。

#### 位运算

![image-20200409162426494](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409162426494.png)

![image-20200409162917922](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409162917922.png)

1. `&` 和 `|` 即使逻辑运算符，也是位运算符。如果两侧的操作数都是boolean类型，就作为逻辑运算符。如果两侧的操作数是整数类型，就是位运算符。
2. `^` 不是数学的乘方，而是 `位的异或` 操作。
3. `&` 按位与：可以实现清零的功能。

#### 字符串连接符(+)

> `+` 运算符两侧的操作数中只要有一个是字符串（String）类型，系统会自动将另一个操作数转为字符串然后再进行连接。

#### 条件运算符

> x ?  y  :  z; 

#### 算数运算符优先级

![image-20200409164431515](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409164431515.png)

1. 一般使用小括号来组织。
2. 逻辑非>逻辑与>逻辑或

### 类型转换

#### 自动类型转换

1. 自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。
2. 当整数转为浮点数的时候，会出现精度损失。
3. 可以将整形常量直接赋值给byte,short,char等类型。不需要进行强制类型转换，只要不超过其数范围即可。

#### 强制类型转换

1. 强制类型转换，又被称为造型，用于显式的转换一个数值的类型。
2. 将一种类型强制转换成另一种类型，而又超出了目标类型的范围，就会被截断为一个完全不同的值。
3. `不能在布尔类型` 和任何数值类型之间做强制类型转换。

##### 强制类型转换时常见的错误和问题

1. 操作较大的数时，要留意是否溢出。
2. `L/l` 的使用，可能和 `1` 造成混乱。需要注意。

## 控制语句

> 所有的布尔表达式中不能使用 `0/1` 进行判断处理

### 选择结构

#### if单选择结构

```java
if (布尔表达式) {
    语句块
}
```

#### if-else双选择结构

```java
if(布尔表达式){
    语句块1
}else{
    语句块2
}
```

#### if-else if-else多选择结构

```java
if(布尔表达式1) {
	语句块1;
} else if(布尔表达式2) {
	语句块2;
}……
else if(布尔表达式n){
    语句块n;
} else {
    语句块n+1;
}
```

#### switch 多选择结构

```java
switch (表达式) {
case 值1: 
	语句序列1;
	[break];
case 值2:
 	语句序列2;
[break];
     … … …      … …
[default:
 	默认语句;]
}
```

+ 这儿的表达式就是填入一个变量，然后与下面的值对比。
+ `default` 语句可以有，也可以舍去。

### 循环结构

+ 循环结构分为两大类：一类是当型，一类是直到型。
+ 当型：当布尔表达式条件为 true 时，反复执行某语句，当布尔表达式的值为 false 时才停止循环。比如：while/for 循环。
+ 直到型：先执行某语句，再判断布尔表达式，如果为 true，再执行某语句，如此反复直到布尔表达式条件为 false 时才停止。比如：do-while 循环。

#### while循环

```java
while (布尔表达式) {
    循环体；
}
```

#### do-while循环

```java
do {
    
} while (布尔表达式);
```

+ do-while 循环的结尾必须有 `;` 
+ while 与 do-while 的区别：do-while 总是保证循环体至少被执行一次。

#### for循环

```java
for (初始表达式; 布尔表达式; 迭代因子) {
	循环体;
}
```

+ A. 初始化部分设置循环变量的初值

+ B. 条件判断部分为任意布尔表达式

+ C. 迭代因子控制循环变量的增减

+ for循环在执行条件判定后，先执行的循环体部分，再执行步进。

#### 嵌套循环

1. break

   + 用于强制退出，不执行循环剩余的语句

2. continue

   + 终止本次循环
   + continue用在while，do-while中，continue 语句立刻跳到循环首部，越过了当前循环的其余部分。
   +  continue用在for循环中，跳到for循环的迭代因子部分。

3. 可以在 `break/continue` 加标签，这样就可以实现多层跳转。

   ```java
    outer: for (int i = 101; i < 150; i++) {
               for (int j = 2; j < i / 2; j++) {
                   if (i % j == 0){
                       continue outer;
                   }
               }
               System.out.print(i + "  ");
           }
   ```

### 方法

#### 语句块

+ 语句块就是方法中的`{}`

#### 方法

1. 格式 

   ```java
   [修饰符1  修饰符2  …]   返回值类型    方法名(形式参数列表){
       Java语句；… … …
    }
   ```

2. 对象的调用方式： `对象名.方法名(实参列表)`

3. 方法的详细说明

   1. 形式参数：在方法生命时用于接受外界传入的数据。
   2. 实参：调用方法时实际传入给方法的数据
   3. 返回值：方法在执行完毕后返回给调用它的环境数据。
   4. 返回值类型：事先约定的返回值的数据类型，如无返回值，必须显式的指定为void

4. Java中进行的方法调用中传递参数时，遵循值传递的原则（传递的都是数据的副本）

5. 基本类型传递的是该数据值的 copy 值。

6. 引用类型传递的是该对象应用的 copy 值，但是指向的是同一个对象。

#### 方法的重载（overload）

1. 方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。
2. 方法调用时，会根据不同参数自动匹配对应的方法。

### 递归结构

1. 递归结构包括两个部分：递归头，递归体
2. 递归头：没有递归头会陷入死循环，递归头就是定义了一个判断的条件。
3. 递归体：什么时候需要调用自身的方法。

## 数组

### 数组的定义

1. 数组是相同类型数据的有序集合。
2. 数组的长度是确定的。数组一旦被创建，它的大小就是不可以改变的。
3. 其元素必须是相同的类型，不允许出现混合类型。
4. 数组类型可以是任何数据类型，包括基本类型和引用类型。
5. 注意：
   1. 数组变量属于引用类型，数组可以看成是对象，每个数组中的每个元素相当于该对象的成员变量。
   2. 数组本身就是对象，Java中对象是堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。

### 数组的声明

```java
type[] arr_name;
```

1. 声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM 才会分配空间，这时候才与长度有关。
2. 声明一个数组的时候并没有数组被真正的创建。
3. 构造一个数组，必须指定数组的长度。

### 数组的初始化

#### 静态初始化

```java
int[] a = {1,4,7};
User[] b = {        
    new User(1001,"zs"),        
    new User(1002,"zed")
};
```

#### 动态初始化

```java
int[] a1 = new int[2];//动态初始化数组，先分配空间；
a1[0]=1;//给数组元素赋值；
a1[1]=2;//给数组元素赋值；
```

#### 默认初始化

```java
int[] c = new int[3]; // 默认给数组赋值，赋值的规则和成员变量默认赋值规则一致。
```

### 数组的遍历

1. 数组元素下边的合法区间：[0,length-1]
2. 遍历数组时可以读取或修改元素的值。
3. `fori` 遍历：可以修改、读取数组元素的值。
4. `for-each` 遍历：只可以读取元素的值。 

### 数组的拷贝

 System类里也包含了一个 `static void arraycopy(object src，int srcpos，object dest， int destpos，int length)` 方法，该方法可以将 `src` 数组里的元素值赋给 `dest` 数组的元素，其中 `srcpos` 指定从 `src` 数组的第几个元素开始赋值， `length` 参数指定将 `src` 数组的多少个元素赋给 `dest` 数组的元素。 

### java.util.Arrays类

1. Arrays类中包含了常用的数组操作，方便我们使用。

2. Arrays类包含了：排序、查找、填充、打印内容等常见操作

3. 排序: `Arrays.sort(a)` 

4. 数组引用类型的排序

   ```java
   class Man implements Comparable {
       int age;
       int id;
       String name;
    
       public Man(int age, String name) {
           super();
           this.age = age;
           this.name = name;
       }
    
       public String toString() {
           return this.name;
       }
    
       public int compareTo(Object o) {
           Man man = (Man) o;
           if (this.age < man.age) {
               return -1;
           }
           if (this.age > man.age) {
               return 1;
           }
           return 0;
       }
   }
   ```

   + 主要就是实现了Comparable中的compareTo。
   + 在compareTo中实现了引用类型的排序。

5. 数组的填充：`Arrays.fill(a,2,4,100);` 将2-4索引的元素替换为100；

6.  二分查找: `Arrays.binarySearch(数组名,查找的元素)` 。 

### 多维数组

![image-20200410122136348](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200410122136348.png)

1. 多维数组可以看成数组为元素的数组。

2. ```java
   int[][] a = new int[3][];
   // a[0] = {1,2,5}; //错误，没有声明类型就初始化
   a[0] = new int[] { 1, 2 };
   a[1] = new int[] { 2, 2 };
   a[2] = new int[] { 2, 2, 3, 4 };
   ```

3. 多为数组在内存中的存储就是这样的（上图）。

4. 我们在开发中一般不使用数组，我们使用容器（collection）。

### 数组存储表格数据

1. ```java
   Object[] a1 = {1001,"高淇",18,"讲师","2006-2-14"};
   Object[] a2 = {1002,"高小七",19,"助教","2007-10-10"};
   Object[] a3 = {1003,"高小琴",20,"班主任","2008-5-5"};
   Object[][]  emps = new Object[3][];
   emps[0] = a1;
   emps[1] = a2;
   emps[2] = a3;
   ```

2. 此处的数据本质不是Object对象。java编译器会自动把基本数据类型“自动装箱”成包装类对象。

## 面向对象基础

### 对象和类的概念

1. 类：我们把类叫做class。类就相当于一个汽车。
2. 对象：我们叫做 `Object,instance(实例)` 。对象就相当于我们通过图纸造出来的汽车。
3. 对象是具体的事物，类是对象的抽象。
4. 类可以看成一类对象的模板，对象可以看成一个类的具体实实例。
5. 类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。

#### 类的定义

1. 每一个源文件必须且只有一个 `public class` ，并且类名和文件名保持一致。

2. 定义好类之后，里面没有任何信息，是一个空类，没有任何的实际意义。

3. 我们需要定义类的具体信息。对于一个类来说，一般有三种常见成员：属性field、方法methods、构造器constructor。这三种成员可以定义零个或者多个。

4. 例： 

   ```java
   public class SxtStu {
       //属性（成员变量）
       int id;
       String sname;
       int age;  
       //方法
       void study(){
           System.out.println("我正在学习！");
       }  
       //构造方法
      SxtStu(){
      }
   }
   ```

   

#### 属性

1. 属性用于该类或者该对象包含的数据或者静态特征。属性作用范围是整个类体。
2. 在定义成员变量时可以对其进行初始化，如果不对其进行初始化，Java使用默认的值对其初始化。
3. ![image-20200410163008179](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200410163008179.png)

4. 属性的定义格式： `[修饰符] 属性类型 属性名 = [默认值];` 

#### 方法

1. 格式：

   ```java
   [修饰符] 方法返回值类型 方法名(形参列表) {
       // n条语句
   } 
   ```

2. 如果时类内部用的方法可以直接设置为私有，这样就不会向外暴漏。

#### 定义类示例和UML图

```java
public class Student {
    // 属性fields
    int id;
    String name;
    int age;
    Computer comp;
    void study() {
        System.out.println("我在学习！" + comp.brand);
    }
    void play() {
        System.out.println("我在玩游戏！");
    }
    //构造方法，用于创建这个类的对象，无参的构造方法可以由系统自动创建。
    Student() {
    }

    //程序执行的入口，必须要有
    public static void main(String[] args) {
        Student stu = new Student(); // 创建一个对象
        //这儿创建的对象就是前边的构造方法，用来创建这个类的对象。现时使用中可以省略不写
        stu.id = 1001;
        stu.name = "zhanghui";
        stu.age = 18;
        Computer c1 = new Computer();
        c1.brand = "联想";
        stu.comp = c1;
        stu.study();
        stu.play();
    }
}
class Computer {
    String brand;
}
```

1. 构造方法，用于创建这个类的对象，无参的构造方法可以由系统自动创建。
2. 这儿创建的对象就是前边的构造方法，用来创建这个类的对象。现时使用中可以省略不写。有参的情况下，一般都会写。
3. ![image-20200410164035398](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200410164035398.png)

### 面向对象的内存分析

1. JVM的内存可以分为三个区域：栈stack、堆heap、方法区method area.
2. 栈（stack）:
   + 栈描述的式方法执行的内存模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）
   + JVM为每一个线程创建了一个栈，用于存放该线程执行方法的信息（实际参数、局部参数等）
   + 栈属于私有线程，不能实现线程之间的共享。
   + 栈的存储特性：先进后出，后进先出。
   + 栈式由系统自动分配，速度快，栈式一个连续的内存空间！
3. 堆（heap）：
   + 堆用于存储创建好的对象和数组（数组也是对象）。
   + JVM只有一个堆，所有数据都被线程间共享。
   + 堆是一个不连续的内存空间，分配灵活，速度慢！
4. 方法区（又叫静态区：method area）：
   + JVM 只有一个方法区，被所有的线程共享！
   + 方法区实际也是堆，只适用于存储类、常量等相关信息！
   + 用来存放程序中永远不变或唯一的内容。（类信息【Class对象】、静态变量、字符串常量等）
5. ![Snipaste_2020-04-10_17-26-56](C:\Users\张辉\Desktop\Snipaste_2020-04-10_17-26-56.jpg)

### 构造方法（constructor）

1. 构造器也叫构造方法，用于对象的初始化。
2. 通过new关键字调用
3. 构造器虽然有返回值，但是不能定义返回值类型（返回值的类型肯定是奔类），不能再构造器里使用return 返回某个值。
4. 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果以定义则编译器不会自动添加。
5. 构造器的方法名必须和类名一致。
6. 构造器可以理解为帮助类进行初始化的方法。

#### 构造方法重载

+ 与普通方法一样，构造方法也可以重载。
+ 重载的使用与普通方法的重载一样。

### 垃圾回收机制（GC）

#### 内存管理

1. Java的内存管理很大程度值得就是对象的管理，其中包括对象空间的分配和释放。
2. 对象空间的分配：使用new关键字创建对象即可。
3. 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有“不可达”对象的内存空间。

#### 垃圾回收过程

1. 发现无用的对象。
2. 回收无用对象占用的内存空间。
3. 垃圾回收机制保证可以将“无用的对象”进行回收。无用对象值得就是没有任何变量引用该对象。

#### 垃圾回收算法

1. 引用计数法：

   + 堆中的每个对象都有一个引用计数。被引用一次，计数加1，被引用变量值为null，则计数减1.直到计数为0.

   + 缺点：“循环引用的无用对象”无法识别。

   + ```java
     s1.friend = s2;
     s2.friend = s1;    
     s1 = null;
     s2 = null;
     // s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。
     ```

2. 引用可达法（根搜索算法）

   + 从开始第一个节点，寻找下一个节点；当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用的节点，即无用的节点。

#### 通用的分代垃圾回收机制

1.  新创建的对象，绝大多数都会存储在Eden中，

2. 当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉， 然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区。
3. 当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。
4. 重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，
5. 当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）
6. 三个回收：
   + Minor GC：用于清理年轻代区域。
   + Major GC：用于清理老年代区域。
   + Full GC：用于清理年轻代、年老代。成本较高。
7.  持久代：用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。

#### JVM调优和Full GC 

1. JVM 调优的过程中很大一部分是对Full GC 的调节。
2. 导致Full GC 可能有以下原因：
   + 年老代（Tenured）被写满
   + 持久代（Perm）被写满
   + System.gc()被显式调用（程序建议启动GC，不是调用GC）
   + 上一次GC之后heap的各域分配策略动态变化

#### 内存泄漏

1. 创建了大量无用对象：拼接字符串时使用了String会造成。
2. 静态集合类的使用（HashMap,Vector,list）
3. 监视器的使用：释放对象时，没有删除相应的监视器。
4. 各种连接对象未关闭。

### this 关键字

1. this 的本质就是“创建好的对象的地址”！由于在构造方法调用前，对象已经创建。因此在构造方法中也可以使用this代表“当前对象”。
2. this 不能用于 static 方法中（static中对象还没有被创建好）。

### static 关键字

1. 在类中，static 声明的成员变量为静态成员变量。
2. 类变量的生命周期和类相同，在整个应用的执行期间都有效。
3. static 的变量为公用变量，属于类。被该类的所有实例共享，在类被载入时显式的初始化。
4. 一般使用“类名.类属性/方法”来调用。
5. static 方法中不可以直接访问`非 static` 的成员。

### 参数传值机制

1. 基本数据类型参数的传值：传递的式值的副本。副本改变不会影响原件。
2. 引用类型参数传值：传递的式值的副本，但是引用类型值得是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，所以说改变了副本的值也会改变原来的值。

### 静态初始化块

> 静态初始化块用于类的初始化操作（初始化时之）！在静态初始化块中不能直接访问static成员

### 静态导入

> 在jdk1.5增加的新功能，其作用是用于导入指定类的静态属性，这样我们就可以直接使用。

## 常用类

### 包装类

![image-20200411213327310](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200411213327310.png)

#### 包装类的用途

1. 作为和基本类型对应的类型存在，方便涉及到对象的操作。
2. 包含每种基本数据类型的相关属性如最大值，最小值等，以及相关的操作方法。

#### 自动装箱和拆箱

1. 自动装箱
   1. 基本类型的数据处于需要对象的环境中时，会自动转化为“对象”。
   2. `Integer i = 5` 在自动装箱中就相当于 `Integer i = Integer.valueOf(5)` 这样的操作，这就是Java的自动装箱
2. 自动拆箱
   1. 没有必要显式的调用intValue(),doubleValue()等转型方法。
   2. 如： `Integer i = 5;int j = i;` 这样的过程就是自动拆箱。
3. 包装类的空指异常
   1. 当 `Integer i = null;int j = i.intValue();`  这样就会造成空指异常。
   2. 因为 i 并没有指向任何对象的实体，所以就不可能操作 intValue()方法。

#### 包装类的缓存问题

1.  如果数据在-128~127这个区间，那么在类加载时就已经为该区间的每个数值创建了对象，并将这256个对象存放到一个名为cache的数组中。每当自动装箱过程发生时(或者手动调用valueOf()时)，就会先判断数据是否在该区间，如果在则直接获取数组中对应的包装类对象的引用，如果不在该区间，则会通过new调用包装类的构造方法来创建对象。 
2. IntegerCache类为Integer类的一个静态内部类，仅供Integer类使用。
3.  一般情况下 IntegerCache.low为-128，IntegerCache.high为127，IntegerCache.cache为内部类的一个静态属性

### String类

#### String

1. String类对象代表不可变的字符序列，因此我们可以将对象称为“不可变对象”。
2. String 类底层创建的数组是final的，也就是常量，只能被赋值一次。
3. String类常用的方法：
   1. 创建返回对象：concat(),replace(),substring(),toLowerCase(),toUpperCase(),trim(),
   2. 提供查功能：endsWith(),startsWith(),indexOf(),lastIndexOf()
   3. 提供比较功能的方法：equals(),equalsIgnoreCase(),compareTo().
   4. 其他方法：charAt(),length().

#### StringBuffer和StringBuilder

1. StringBuffer 线程安全，做线程同步检查，效率较低。
2. StringBuilder 线程不安全，不做线程同步检查，效率高。
3. 这俩的方法都是返回自己本身。
4.  append(…)  添加字符序列，仍然返回自身对象。 
5.  delete(int start,int end)   删除从start开始到end-1为止的一段字符序列，仍然返回自身对象 
6.  deleteCharAt(int index)    移除此序列指定位置上的 char，仍然返回自身对象 
7.  insert(…)   在指定位置插入字符序列，仍然返回自身对象 
8.  reverse()    用于将字符序列逆序，仍然返回自身对象。 
9.  toString() 返回此序列中数据的字符串表示形式 

### 时间类

>  JDK1.1之后，日期操作一般使用Calendar类，而字符串的转化使用DateFormat类。 

#### DateFormat类和SimpleDateFormat类

![image-20200411220720702](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200411220720702.png)

```java
// 把时间对象按照"格式字符串指定的格式"转成相应的字符串
DateFormat df = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
// SimpleDateFormat是DateFormat的一个子类
String str = df.format(new Date(40000000));
System.out.println(str);

// 把字符串按照“格式字符串指定格式”转成相应的时间对象
DateFormat df2 = new SimpleDateFormat("yyyy年MM月DD日 hh时mm分ss秒");
Date date = df2.parse("2020年04月07日 12时16分40秒");
System.out.println(date);

// 测试其他的格式字符。比如：利用D，获取本事件对象是所处年份的第几天。
DateFormat df3 = new SimpleDateFormat("D");
// SimpleDateFormat是DateFormat的一个子类
String str3 = df3.format(new Date());
System.out.println(str3);
```



#### Calendar日历类

>  GregorianCalendar 是 Calendar 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。 

```java
public static void printCalendar(Calendar c) {
    // 打印：1918年10月10日 11：23：45 周三
    int year = c.get(Calendar.YEAR);
    int month = c.get(Calendar.MONTH) + 1;
    int date = c.get(Calendar.DAY_OF_MONTH);
    int dayweek = c.get(Calendar.DAY_OF_WEEK) - 1;
    String datweek2 = dayweek==0?"日":dayweek+"";

    int hour = c.get(Calendar.HOUR);
    int minute = c.get(Calendar.MINUTE);
    int second = c.get(Calendar.SECOND);

    System.out.println(year + "年" + month + "月" + date + "日" + hour + "时" + minute + "分" + second + "秒" + " 周" + datweek2);
}
```

### Math类

1. abs 绝对值

2. acos,asin,atan,cos,sin,tan 三角函数

3. sqrt 平方根

4. pow(double a, double b) a的b次幂

5. max(double a, double b) 取大值

6. min(double a, double b) 取小值

   7. ceil(double a) 大于a的最小整数

   8. floor(double a) 小于a的最大整数

9. random() 返回 0.0 到 1.0 的随机数
10. long round(double a) double型的数据a转换为long型(四舍五入)

11. toDegrees(double angrad) 弧度->角度

12. toRadians(double angdeg) 角度->弧度
13. java.lang.Math提供类一系列静态方法用于科学计算。

### File类

1.  java.io.File类：代表文件和目录。 在开发中，读取文件、生成文件、删除文件、修改文件的属性时经常会用到本类。 

2.  ```java
   File f = new File("d:/b.txt");
   f.renameTo(new File("D:/b.txt"));
   System.out.println("File是否存在："+f.exists());
   System.out.println("File是否是目录："+f.isDirectory());
   System.out.println("File是否是文件："+f.isFile());
   System.out.println("File最后修改时间："+new Date(f.lastModified()));
   System.out.println("File的大小："+f.length());
   System.out.println("File的文件名："+f.getName());
   System.out.println("File的目录路径："+f.getPath());
   ```

3. 关于文件操作的很多文件都在这个包中

### 枚举

1. 格式： `enum 枚举名 {枚举体（常量列表）}`

2. ```java
   enum` `Season {
     ``SPRING, SUMMER, AUTUMN, WINDER 
   }
   ```

3.  枚举实质上还是类!而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final修饰的。可以直接通过枚举类型名使用它们。 

## 异常机制

### 异常分类

1. Throwable分为Error和Exception.

#### Error

1. Error是程序无法处理的错误，是JVM出现的问题。
2. 大多数情况下重启虚拟机则可以解决。

#### Exception

1. RuntimeException 运行时异常
2. CheckedException 已检查异常
3. 抛出异常：throw
4. 捕获异常：try-catch

#### RuntimeException

1. 运行时异常包括：被0除，数组下标越界，空指针等。
2. 通常需要增加逻辑处理来避免这些异常。

#### CheckedException

1. 这就是我们在书写程序时遇到的错误。
2. 不处理，就不能通过编译。

#### try-catch-finally

1. 如果出现异常，可以通过catch来捕获异常并处理。
2. 最后一步的finally所指定的代码都要被执行。
3.  即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。 
4.   finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行。 

####  **throws** 

> 将当前遇到的异常传递给下一层处理。

### 自定义异常

```java
/**IllegalAgeException：非法年龄异常，继承Exception类*/
class IllegalAgeException extends Exception {
    //默认构造器
    public IllegalAgeException() {
     
    }
    //带有详细信息的构造器，信息存储在message中
    public IllegalAgeException(String message) {
        super(message);
    }
}
```

1. 要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。

2. 处理异常不可以代替简单测试---只在异常情况下使用异常机制。

3. 不要进行小粒度的异常处理---应该将整个任务包装在一个try语句块中。

4. 异常往往在高层处理 。

## 面向对象进阶

### 继承（extends）

+ 继承的意思即是对一个内容进行扩展构成一个新的内容。
+ 比如：动物可以继承扩展为哺乳动物和爬行动物；他们的底层都是相同的，但是总有一些不一样的地方。
+ Object类是所有Java类的根基类，也就是所有的Java对象都拥有Object类的属性和方法。

#### instanceof

1. `instanceof` 是二元运算符，左边是对象，右边是类

2. 当对象是右边类或子类所创建的对象时，返回true，否则false.

3. ```java
   // Student类是Person的一个子类
   Student s = new Student("zs",190,"c++");
   System.out.println(s instanceof Person);
   System.out.println(s instanceof Student);
   ```

#### 继承使用应注意的要点

1. 父类也成为超类、基类、派生类等。
2. Java中只有单继承（但是接口可以多继承）。多继承会引起会乱，是的继承链过于复杂，系统难于维护。
3. Java中类没有多继承，接口有多继承。
4. 子类继承父类，可以得到父类所有属性和方法（除了父类的构造方法），但不见得可以直接访问（父类的私有属性和方法）。
5. 在定义类是没有调用 extends ，则他的父类是： java.lang.Object

#### 方法的重写（override）

1. 重写的条件

   + 方法名和形参列表必须相同。
   + 返回值类型和声明异常类型，子类小于等于父类。
   + 访问权限，子类大于等于父类。

2. ```java
   public class TestOverride {
       public static void main(String[] args) {
           Vehicle v1 = new Vehicle();
           Vehicle v2 = new Horse();
           Vehicle v3 = new Plane();
           v1.run();
           v2.run();
           v3.run();
           v2.stop();
           v3.stop();
       }
   }
   class Vehicle { // 交通工具类
       public void run() {
           System.out.println("跑....");
       }
       public void stop() {
           System.out.println("停止不动");
       }
   }
   class Horse extends Vehicle { // 马也是交通工具
       public void run() { // 重写父类方法
           System.out.println("四蹄翻飞，嘚嘚嘚...");
       }
   }
    
   class Plane extends Vehicle {
       public void run() { // 重写父类方法
           System.out.println("天上飞！");
       }
       public void stop() {
           System.out.println("空中不能停，坠毁了！");
       }
   }  
   ```

3. 继承的方法在使用的时候，必须new.

4. new的时候可以使用 ` Vehicle v3 = new Plane(); ` ，但是在后边的对象转型的时候，必须注意（不能转错类型，因为一个父类可能存在多个子类）。

### 一些基础方法（toString,==,equals）

#### toString 

1. Object类中定义了 `public String toString()` 方法，其返回值是String类型的。
2. Object类中的toString方法是输出：类名+@+16进制的hashcode
3. 所以在一般使用中toString 方法一般都会被重写。

#### == 和 equals

1. `==` 海表比较双方是都夏姑娘同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等则为同一个对象。
2. `equals` 方法默认就是比较两个对象的hashcode，是同一个类型的引用时返回true。一般我们会重写equals方法。
3. JDK提供的很多类中都对equals方法进行类重写（重写之后一般都是比较内容值是否相等）。

### super关键字和继承树

1. super时直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。
2. 使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。
3. super()方法构造函数都会默认调用。

4. 继承方法使用的时候会向上寻找我们的调用（继承树回溯）。

### 封装

+ 提高代码的安全性
+ 提高代码的复用性
+ “高内聚”：封装细节，便于修改内部代码，提高可维护性。
+ “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。

#### 访问控制

1. `private ` 表示私有，只有自己类能访问 
   + 只能在自己的类中使用，其他地方都不能使用
   + 使用范围：同一个类（一个类就是一个.java中的一个class）
2. `default` 表示没有修饰符修饰，只有同一个包的类能访问
   + 在变量或者方法没有被修饰的情况下默认为 default 的，这样就最大就只能在同一个包中使用
   + 使用范围：同一个类，同一个包(一个包就是package中)
3. `protected` 表示可以被同一个包的类以及其他包中的子类访问(好像不太经常使用)
   + 在被 protected 修饰的情况下，变量或者方法就最多被继承它的子类所使用。
   + 使用范围：同一个类，同一个包，它的子类(使用 extends 继承了它的子类，这儿的继承也就只能在同一个)
4. `public` 表示可以被该项目的所有包中的所有类访问

#### 封装的细节

1. 一般使用 `private` 访问权限
2. 提供相应的 get/set 方法来访问相关属性，这些方法通常是public的。
3. boolean 变量的 get 方法是 is 开头的。
4.  一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 

### 多态（polymorphism）

1. 多态是方法的多态，不是属性的多态

2. 多态的存在有三个必要条件：继承，方法重写，父类引用指向子类对象。

3. 父类引用指向子类对象后，该父类引用调用子类重写的方法，此时多态就出现了。

4. 简单来说，多态就是多个子类继承同一个父类，然后对父类中的某个方法都进行了重写（override）。这样就构成了多态。

5. ```java
   // 有了多态，只需要让增加的这个类继承Animal类就可以了。
   static void animalCry(Animal a) {
       a.shout();
   }
   ```

6. 不管是什么动物叫，我们只要把对象传进去，就能发出准确的叫声。

### 对象的转型(casting)

1. 父类引用指向子类对象，我们成这个过程为向上转型，属于自动类型转换。
2. 向上转型后的父类引用变量只能调用他编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要强制转型，称之为向下转型。
3. 类型转换时应该注意异常的处理。

### final关键字

1. final修饰的变量不能被二次赋值。
2. final修饰的方法，不能被重写。
3. final修饰的类不能被继承。

### 抽象方法和抽象类（abstract）

#### 抽象方法

+ 使用abstract修饰的方法，没有方法体，只有声明。
+ 定义的是一种规范，告诉子类必须要给抽象方法提供具体的实现。

#### 抽象类

+ 包含抽象方法的类就是抽象类。
+  通过abstract方法定义规范，然后要求子类必须定义具体实现 
+  通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 

#### 抽象类使用要求

1. `抽象方法的类只能定义成抽象类。`
2. 抽象类不能实例化，也就是不能用 `new` 来实例化抽象类。
3. 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来 `new` 实例，只能用来被子类调用。
4. 抽象类只能用来被继承。
5. 抽象方法必须被子类实现。

### 接口（interface）

+ 普通类：具体实现
+ 抽象类：具体实现，规范（抽象方法）。
+ 接口：规范

#### 接口的定义

1. 声明格式：

   ```java
   [访问修饰符]  interface 接口名   [extends  父接口1，父接口2…]  {
   常量定义；  
   方法定义；
   }
   ```

2. 访问修饰符：只能时public或者默认（default）。

3. 接口名：和类名采用相同的命名机制；首字母大写和驼峰原则；

4. extends：接口可以多继承，但是 `继承的都是接口` 。

5. 常量：接口中的属性只能是常量，总是 `public static final` 修饰的，不写也是如此。

6. 方法：接口中的方法只能是 `public abstract` ，省略的话也是 `public abstract` ，也就意味着方法是抽象的，只需要规范即可，不需要实现。

#### 接口的使用

1. 子类通过 `implements` 来实现接口中的规范。

2. 接口不能创建实例，但是可用于声明引用变量类型。

3. 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是 `public` 的。

4. 在JDK1.8后，接口中包含了静态常量，抽象方法，静态方法。不能有普通属性，构造方法。

5. ```java
   public class TestInterface {
       public static void main(String[] args) {
           Volant volant = new Angel();
           volant.fly();
           System.out.println(Volant.FLY_HIGHT);
            
           Honest honest = new GoodMan();
           honest.helpOther();
       }
   }
   /**飞行接口*/
   interface Volant { 
       int FLY_HIGHT = 100;  // 总是：public static final类型的；
       void fly();   //总是：public abstract void fly();
   }
   /**善良接口*/
   interface Honest { 
       void helpOther();
   }
   /**Angle类实现飞行接口和善良接口*/
   class Angel implements Volant, Honest{
       public void fly() {
           System.out.println("我是天使，飞起来啦！");
       }
       public void helpOther() {
           System.out.println("扶老奶奶过马路！");
       }
   }
   class GoodMan implements Honest {
      public void helpOther() {
           System.out.println("扶老奶奶过马路！");
       }  
   }
   class BirdMan implements Volant {
       public void fly() {
           System.out.println("我是鸟人，正在飞！");
       }
   }
   ```

#### 接口的多继承

```java
interface A {
    void testa();
}
interface B {
    void testb();
}
/**接口可以多继承：接口C继承接口A和B*/
interface C extends A, B {
    void testc();
}
public class Test implements C {
    public void testc() {
    }
    public void testa() {
    }
    public void testb() {
    }
}
```

### 内部类

#### 非静态/静态内部类

```java
public class TestInnerClass {
    public static void main(String[] args) {
        Outer outer = new Outer();
        /**
         * 上边是创建外部类
         * 下边创建内部类
         *
         * 非静态内部类可以直接访问外部类成员，但是外部类不能访问非静态内部类的成员
         * 非静态内部类不能有静态方法、静态属性和静态初始化块。
         * 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。
         */
        
        // 创建非静态内部类
        Outer.Inner inner = new Outer().new Inner();
        inner.show();
        
        // 创建静态内部类，静态内部类不依托于外部类
        Outer2.Inner2 inner = new Outer.Inner2();
    }
}
class Outer {
    private int age = 10;

    public void testOuter() {
        System.out.println("Outer.testOuter");
    }

    class Inner {
        int age = 20;
        public void show() {
            int age = 30;
            System.out.println("外部类的成员变量age:" + Outer.this.age);
            System.out.println("内部类的成员变量age:" + this.age);
            System.out.println("局部变量age:" + age);
        }
    }
    static class Inner2{
    }
}
```

#### 匿名内部类

1. 语法： `new 父类构造器（实参类表）\实现接口 () { 匿名内部类类体 }`

2. 匿名内部类只使用一次。

3. ```java
   public class TestAnnonymousInnerClass {
   
       public static void test01(A a){
           System.out.println("ajd");
           a.aa();
       }
       public static void main(String[] args) {
           TestAnnonymousInnerClass.test01(new A() {
               @Override
               public void aa() {
                   System.out.println("Test");
               }
           });
       }
   }
   interface A{
       void aa();
   }
   ```

### String 基础

>  String类是不可变字符串，方法在之前写了。

#### String常用方法

![image-20200413000210787](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200413000210787.png)

### 常量池

#### 全局字符串常量池（String Pool）

> 存放的内容是类加载完成后存到String Pool中的，每个VM只有一份，存放的是字符串常量的引用值。

#### class文件常量池（Class Constant Pool）

> class常量池是在编译的时候每个class都有的，在编译阶段存放的是常量（文本字符串、final常量等）和符号的引用。

#### 运行时常量池（Runtime Constant Pool）

>  运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。 