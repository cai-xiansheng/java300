# Java基础



+ 编译 `.java` 为 `class` 文件：`javac Welcome.java`
+ 执行：`java Welcome`



## 数据类型和运算符

### 注释

```java
//单行注释
/*
多行注释
	*/
/**
 *文档注释
 */
```

1. 在类的方法中使用单行注释
2. 在类中使用文档注释

### 标识符

#### 标识符规则

1. 标识符必须是以字母、下划线、美元符号开头。
2. 标识符其他部分可以是字母、下划线、美元符、数字的任意组合。
3. Java标识符大小写敏感，且长度无限制。
4. 标识符不可以是Java关键字。

#### 标识符使用规范

1. 表示`类名`的标识符：每个单词的手写字母大写.Man,GoodMan
2. 表示方法和变量的标识符，第一个的单词小写，从第二个单词开始首字母大写。（也就是驼峰法命名）。

### Java中的关键字/保留字

| abstract   | assert  | boolean   | break     | byte       | case        |
| ---------- | ------- | --------- | --------- | ---------- | ----------- |
| catch      | char    | class     | const     | continue   | default     |
| do         | double  | else      | extends   | final      | finally     |
| float      | for     | goto      | if        | implements | import      |
| instanceof | int     | interface | long      | native     | new         |
| null       | package | private   | protected | public     | return      |
| short      | static  | strictfp  | super     | switch     | sychronized |
| this       | throw   | throws    | transient | try        | void        |
| volatile   | while   |           |           |            |             |

### 变量

#### 变量的本质

1. 变量的本质上就是代表一个“可操作的存储空间”，空间的位置是确定的，到那时里面放置什么值不确定。
2. 我们可以通过变量名来访问“对应的存储空间”，从而操作这个“存储空间”存储的值。

#### 变量的分类

| 类型                 | 声明位置           | 从属于      |                           声明周期                           |
| -------------------- | ------------------ | ----------- | :----------------------------------------------------------: |
| 局部变量             | 方法或语句块内部   | 方法/语句块 |   从声明位置开始，直到方法或语句块执行完毕，局部变量消失。   |
| 成员变量（实例变量） | 类内部，方法外部   | 对象        | 对象创建，成员变量也跟着创建，对象消失，成员变量也跟着消失。 |
| 静态变量（类变量）   | 类内部，static修饰 | 类          |      类被加载，静态变量就有效；类被卸载，静态变量消失。      |

### 常量

1. 常量通常是指一个固定的值。
2. 在Java中，主要是利用 `final` 来定义一个常量。常量一旦被初始化后不能在更改其值。
3. 常量声明格式 `final type varname = value;`

#### 变量和常量命名规范

1. 多有变量、方法、类名：见名知意
2. 类成员变量：首字母小写和驼峰法原则：monthSalary
3. 局部变量：首字母小写和驼峰原则
4. 常量：大写字母和下划线：MAX_VALUE
5. 类名：首字母大写和驼峰原则
6. 方法名：首字母小写和驼峰原则：run()

### 基本数据类型

+ Java的数据类型可分为两大类：基本数据类型（primitive data type）和引用数据类型（reference data type）。
+ 数值值 - byte、short、int、long、float、double
+ 字符型 - char
+ 布尔型 - boolean

![image-20200409115800605](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409115800605.png)

#### 整形变量/常量

| 类型  | 占用存储空间 | 表数范围                   |
| ----- | ------------ | -------------------------- |
| byte  | 1字节        | -2^7 ~ 2^7-1（-128 ~ 127） |
| short | 2字节        | -2^15 ~ 2^15 - 1（3万）    |
| int   | 4字节        | -2^31 ~ 2^31 - 1（21亿）   |
| long  | 8字节        | -2^63 ~ 2^63 - 1           |

1. 十进制整数：99，-500
2. 八进制整数，要求以0开头：015
3. 十六进制数，要求以0x或0X开头：0x15
4. 二进制数，要求以0b或0B开头：0b01110011
5. `long` 型常量声明时必须加`L` ，不然会别编译为int，还会报错： `long b = 5555555555555555555555L;`

#### 浮点型变量/常量

| 类型   | 占用存储空间 | 表数范围               |
| ------ | ------------ | ---------------------- |
| float  | 4字节        | -3.403E38 ~ 3.403E38   |
| double | 8字节        | -1.798E308 ~ 1.798E308 |

1. 带小数的数据在Java中称为浮点数。浮点数可分为 `float` 类型和 `double` 类型。
2. `float` 类型又被称为单精度类型，尾数可以精确到 `7` 位有效数字，在很多情况下， `float` 类型的精度很难满足需求。
3. `double` 类型的数值的精度约是 `float` 类型的两倍，又被称作双精度类型，绝大多数部分的应用程序都采用 `double` 类型，
4. 浮点数常量的默认类型也是 `double`。
5. `float` 类型的数值有一个后缀 `f` 或者 `F` ，没有后缀 `f/F`的浮点数被默认为 `double` 类型。
6. 浮点数 `float/double` 的数据不适合在不允许舍入误差的领域。
7. `BigDecimal` 类不产生舍入误差，实现了任意精度的浮点运算。 ` BigDecimal bd = BigDecimal.valueOf(1.0); ` 加减乘除使用的相关方法。
8. `BigInteger` 实现了任意精度的整数运算。

##### Java浮点类型常量有两种表示形式

+ 十进制数形式：3.14，314.0，0.314
+ 科学记数形式：314e2，314E2，314E-2

#### 字符型变量/常量

1. 字符型在Java中占2个字节。

2. 在Java职工使用单引号来表示字符常量：'A'

3. char 类型用来表示在 Unicode 编码表中的字符。

4. 转义字符

   | 转义符 | 含义            | Unicode值 |
   | ------ | --------------- | --------- |
   | \b     | 退格(backspace) | \u0008    |
   | \n     | 换行            | \u000a    |
   | \r     | 回车            | \u000d    |
   | \t     | 制表符(tab)     | \u0009    |
   | \\"    | 双引号          | \u0022    |
   | \\'    | 单引号          | \u0027    |
   | \\\    | 反斜杠          | \u005c    |

5. String的底层实现就是字符序列。

#### boolean 类型

1. `boolean` 类型有两个常量值： `true/false` 
2. `boolean` 在内存中占一位（不是一个字节）。
3. 不可以用`0/1`表示`true/false`

### 运算符

![image-20200409141113851](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409141113851.png)

#### 算数运算符

+ 二元运算符：+，-，*，/，%
+ 二元运算符顾名思义就是需要两个操作数才能完成运算的运算符
+ 一元运算符：++，--

##### 整数运算规则

1. 如果两个操作数有一个位 `long` ，则结果也为long。
2. 没有long时，结果位int。即使操作数全部为short，byte，结果也是int。

##### 浮点数运算规则

1. 如果两个操作数有一个为 `double` ，则结果为 `double`。
2. 只有两个数都是 `float` ，则结果才会为`float`

##### 取模运算规则

1. 操作数可以为浮点数，一般使用整数，结果是余数。
2. 余数的符号和左边的操作数相同：7%3=1，-7%3=-1，7%-3=1。

#### 赋值及其扩展赋值运算符

1. `+=,-=,*=,/=,%=`
2. 这些扩展运算符都是压缩了运算。

#### 关系运算符

![image-20200409142530815](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409142530815.png)

1. `=` 是赋值运算符
2. `==,!=` 是所有（基本和引用）数据类型都可以使用；但是在使用 `==` 的情况下一般都使用 `equals`
3. `>,>=,<,<=` 仅针对数值类型（byte/short/int/long，float/double，以及char）

#### 逻辑运算符

![image-20200409161634952](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409161634952.png)

1. 逻辑运算的操作数和运算结果都是boolean值。
2. 短路与和短路或采用短路的方式。从左到右计算，如果只通过运算操作符左边的操作数就能够确定该逻辑表达式，则不会继续计算操作符右边的操作数，提高效率。

#### 位运算

![image-20200409162426494](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409162426494.png)

![image-20200409162917922](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409162917922.png)

1. `&` 和 `|` 即使逻辑运算符，也是位运算符。如果两侧的操作数都是boolean类型，就作为逻辑运算符。如果两侧的操作数是整数类型，就是位运算符。
2. `^` 不是数学的乘方，而是 `位的异或` 操作。
3. `&` 按位与：可以实现清零的功能。

#### 字符串连接符(+)

> `+` 运算符两侧的操作数中只要有一个是字符串（String）类型，系统会自动将另一个操作数转为字符串然后再进行连接。

#### 条件运算符

> x ?  y  :  z; 

#### 算数运算符优先级

![image-20200409164431515](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200409164431515.png)

1. 一般使用小括号来组织。
2. 逻辑非>逻辑与>逻辑或

### 类型转换

#### 自动类型转换

1. 自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。
2. 当整数转为浮点数的时候，会出现精度损失。
3. 可以将整形常量直接赋值给byte,short,char等类型。不需要进行强制类型转换，只要不超过其数范围即可。

#### 强制类型转换

1. 强制类型转换，又被称为造型，用于显式的转换一个数值的类型。
2. 将一种类型强制转换成另一种类型，而又超出了目标类型的范围，就会被截断为一个完全不同的值。
3. `不能在布尔类型` 和任何数值类型之间做强制类型转换。

##### 强制类型转换时常见的错误和问题

1. 操作较大的数时，要留意是否溢出。
2. `L/l` 的使用，可能和 `1` 造成混乱。需要注意。

## 控制语句

> 所有的布尔表达式中不能使用 `0/1` 进行判断处理

### 选择结构

#### if单选择结构

```java
if (布尔表达式) {
    语句块
}
```

#### if-else双选择结构

```java
if(布尔表达式){
    语句块1
}else{
    语句块2
}
```

#### if-else if-else多选择结构

```java
if(布尔表达式1) {
	语句块1;
} else if(布尔表达式2) {
	语句块2;
}……
else if(布尔表达式n){
    语句块n;
} else {
    语句块n+1;
}
```

#### switch 多选择结构

```java
switch (表达式) {
case 值1: 
	语句序列1;
	[break];
case 值2:
 	语句序列2;
[break];
     … … …      … …
[default:
 	默认语句;]
}
```

+ 这儿的表达式就是填入一个变量，然后与下面的值对比。
+ `default` 语句可以有，也可以舍去。

### 循环结构

+ 循环结构分为两大类：一类是当型，一类是直到型。
+ 当型：当布尔表达式条件为 true 时，反复执行某语句，当布尔表达式的值为 false 时才停止循环。比如：while/for 循环。
+ 直到型：先执行某语句，再判断布尔表达式，如果为 true，再执行某语句，如此反复直到布尔表达式条件为 false 时才停止。比如：do-while 循环。

#### while循环

```java
while (布尔表达式) {
    循环体；
}
```

#### do-while循环

```java
do {
    
} while (布尔表达式);
```

+ do-while 循环的结尾必须有 `;` 
+ while 与 do-while 的区别：do-while 总是保证循环体至少被执行一次。

#### for循环

```java
for (初始表达式; 布尔表达式; 迭代因子) {
	循环体;
}
```

+ A. 初始化部分设置循环变量的初值

+ B. 条件判断部分为任意布尔表达式

+ C. 迭代因子控制循环变量的增减

+ for循环在执行条件判定后，先执行的循环体部分，再执行步进。

#### 嵌套循环

1. break

   + 用于强制退出，不执行循环剩余的语句

2. continue

   + 终止本次循环
   + continue用在while，do-while中，continue 语句立刻跳到循环首部，越过了当前循环的其余部分。
   +  continue用在for循环中，跳到for循环的迭代因子部分。

3. 可以在 `break/continue` 加标签，这样就可以实现多层跳转。

   ```java
    outer: for (int i = 101; i < 150; i++) {
               for (int j = 2; j < i / 2; j++) {
                   if (i % j == 0){
                       continue outer;
                   }
               }
               System.out.print(i + "  ");
           }
   ```

### 方法

#### 语句块

+ 语句块就是方法中的`{}`

#### 方法

1. 格式 

   ```java
   [修饰符1  修饰符2  …]   返回值类型    方法名(形式参数列表){
       Java语句；… … …
    }
   ```

2. 对象的调用方式： `对象名.方法名(实参列表)`

3. 方法的详细说明

   1. 形式参数：在方法生命时用于接受外界传入的数据。
   2. 实参：调用方法时实际传入给方法的数据
   3. 返回值：方法在执行完毕后返回给调用它的环境数据。
   4. 返回值类型：事先约定的返回值的数据类型，如无返回值，必须显式的指定为void

4. Java中进行的方法调用中传递参数时，遵循值传递的原则（传递的都是数据的副本）

5. 基本类型传递的是该数据值的 copy 值。

6. 引用类型传递的是该对象应用的 copy 值，但是指向的是同一个对象。

#### 方法的重载（overload）

1. 方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法。
2. 方法调用时，会根据不同参数自动匹配对应的方法。

### 递归结构

1. 递归结构包括两个部分：递归头，递归体
2. 递归头：没有递归头会陷入死循环，递归头就是定义了一个判断的条件。
3. 递归体：什么时候需要调用自身的方法。

## 数组

### 数组的定义

1. 数组是相同类型数据的有序集合。
2. 数组的长度是确定的。数组一旦被创建，它的大小就是不可以改变的。
3. 其元素必须是相同的类型，不允许出现混合类型。
4. 数组类型可以是任何数据类型，包括基本类型和引用类型。
5. 注意：
   1. 数组变量属于引用类型，数组可以看成是对象，每个数组中的每个元素相当于该对象的成员变量。
   2. 数组本身就是对象，Java中对象是堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。

### 数组的声明

```java
type[] arr_name;
```

1. 声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM 才会分配空间，这时候才与长度有关。
2. 声明一个数组的时候并没有数组被真正的创建。
3. 构造一个数组，必须指定数组的长度。

### 数组的初始化

#### 静态初始化

```java
int[] a = {1,4,7};
User[] b = {        
    new User(1001,"zs"),        
    new User(1002,"zed")
};
```

#### 动态初始化

```java
int[] a1 = new int[2];//动态初始化数组，先分配空间；
a1[0]=1;//给数组元素赋值；
a1[1]=2;//给数组元素赋值；
```

#### 默认初始化

```java
int[] c = new int[3]; // 默认给数组赋值，赋值的规则和成员变量默认赋值规则一致。
```

### 数组的遍历

1. 数组元素下边的合法区间：[0,length-1]
2. 遍历数组时可以读取或修改元素的值。
3. `fori` 遍历：可以修改、读取数组元素的值。
4. `for-each` 遍历：只可以读取元素的值。 

### 数组的拷贝

 System类里也包含了一个 `static void arraycopy(object src，int srcpos，object dest， int destpos，int length)` 方法，该方法可以将 `src` 数组里的元素值赋给 `dest` 数组的元素，其中 `srcpos` 指定从 `src` 数组的第几个元素开始赋值， `length` 参数指定将 `src` 数组的多少个元素赋给 `dest` 数组的元素。 

### java.util.Arrays类

1. Arrays类中包含了常用的数组操作，方便我们使用。

2. Arrays类包含了：排序、查找、填充、打印内容等常见操作

3. 排序: `Arrays.sort(a)` 

4. 数组引用类型的排序

   ```java
   class Man implements Comparable {
       int age;
       int id;
       String name;
    
       public Man(int age, String name) {
           super();
           this.age = age;
           this.name = name;
       }
    
       public String toString() {
           return this.name;
       }
    
       public int compareTo(Object o) {
           Man man = (Man) o;
           if (this.age < man.age) {
               return -1;
           }
           if (this.age > man.age) {
               return 1;
           }
           return 0;
       }
   }
   ```

   + 主要就是实现了Comparable中的compareTo。
   + 在compareTo中实现了引用类型的排序。

5. 数组的填充：`Arrays.fill(a,2,4,100);` 将2-4索引的元素替换为100；

6.  二分查找: `Arrays.binarySearch(数组名,查找的元素)` 。 

### 多维数组

![image-20200410122136348](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200410122136348.png)

1. 多维数组可以看成数组为元素的数组。

2. ```java
   int[][] a = new int[3][];
   // a[0] = {1,2,5}; //错误，没有声明类型就初始化
   a[0] = new int[] { 1, 2 };
   a[1] = new int[] { 2, 2 };
   a[2] = new int[] { 2, 2, 3, 4 };
   ```

3. 多为数组在内存中的存储就是这样的（上图）。

4. 我们在开发中一般不使用数组，我们使用容器（collection）。

### 数组存储表格数据

1. ```java
   Object[] a1 = {1001,"高淇",18,"讲师","2006-2-14"};
   Object[] a2 = {1002,"高小七",19,"助教","2007-10-10"};
   Object[] a3 = {1003,"高小琴",20,"班主任","2008-5-5"};
   Object[][]  emps = new Object[3][];
   emps[0] = a1;
   emps[1] = a2;
   emps[2] = a3;
   ```

2. 此处的数据本质不是Object对象。java编译器会自动把基本数据类型“自动装箱”成包装类对象。

## 面向对象基础

### 对象和类的概念

1. 类：我们把类叫做class。类就相当于一个汽车。
2. 对象：我们叫做 `Object,instance(实例)` 。对象就相当于我们通过图纸造出来的汽车。
3. 对象是具体的事物，类是对象的抽象。
4. 类可以看成一类对象的模板，对象可以看成一个类的具体实实例。
5. 类是用于描述同一类型的对象的一个抽象概念，类中定义了这一类对象所应具有的共同的属性、方法。

#### 类的定义

1. 每一个源文件必须且只有一个 `public class` ，并且类名和文件名保持一致。

2. 定义好类之后，里面没有任何信息，是一个空类，没有任何的实际意义。

3. 我们需要定义类的具体信息。对于一个类来说，一般有三种常见成员：属性field、方法methods、构造器constructor。这三种成员可以定义零个或者多个。

4. 例： 

   ```java
   public class SxtStu {
       //属性（成员变量）
       int id;
       String sname;
       int age;  
       //方法
       void study(){
           System.out.println("我正在学习！");
       }  
       //构造方法
      SxtStu(){
      }
   }
   ```

   

#### 属性

1. 属性用于该类或者该对象包含的数据或者静态特征。属性作用范围是整个类体。
2. 在定义成员变量时可以对其进行初始化，如果不对其进行初始化，Java使用默认的值对其初始化。
3. ![image-20200410163008179](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200410163008179.png)

4. 属性的定义格式： `[修饰符] 属性类型 属性名 = [默认值];` 

#### 方法

1. 格式：

   ```java
   [修饰符] 方法返回值类型 方法名(形参列表) {
       // n条语句
   } 
   ```

2. 如果时类内部用的方法可以直接设置为私有，这样就不会向外暴漏。

#### 定义类示例和UML图

```java
public class Student {
    // 属性fields
    int id;
    String name;
    int age;
    Computer comp;
    void study() {
        System.out.println("我在学习！" + comp.brand);
    }
    void play() {
        System.out.println("我在玩游戏！");
    }
    //构造方法，用于创建这个类的对象，无参的构造方法可以由系统自动创建。
    Student() {
    }

    //程序执行的入口，必须要有
    public static void main(String[] args) {
        Student stu = new Student(); // 创建一个对象
        //这儿创建的对象就是前边的构造方法，用来创建这个类的对象。现时使用中可以省略不写
        stu.id = 1001;
        stu.name = "zhanghui";
        stu.age = 18;
        Computer c1 = new Computer();
        c1.brand = "联想";
        stu.comp = c1;
        stu.study();
        stu.play();
    }
}
class Computer {
    String brand;
}
```

1. 构造方法，用于创建这个类的对象，无参的构造方法可以由系统自动创建。
2. 这儿创建的对象就是前边的构造方法，用来创建这个类的对象。现时使用中可以省略不写。有参的情况下，一般都会写。
3. ![image-20200410164035398](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200410164035398.png)

### 面向对象的内存分析

1. JVM的内存可以分为三个区域：栈stack、堆heap、方法区method area.
2. 栈（stack）:
   + 栈描述的式方法执行的内存模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）
   + JVM为每一个线程创建了一个栈，用于存放该线程执行方法的信息（实际参数、局部参数等）
   + 栈属于私有线程，不能实现线程之间的共享。
   + 栈的存储特性：先进后出，后进先出。
   + 栈式由系统自动分配，速度快，栈式一个连续的内存空间！
3. 堆（heap）：
   + 堆用于存储创建好的对象和数组（数组也是对象）。
   + JVM只有一个堆，所有数据都被线程间共享。
   + 堆是一个不连续的内存空间，分配灵活，速度慢！
4. 方法区（又叫静态区：method area）：
   + JVM 只有一个方法区，被所有的线程共享！
   + 方法区实际也是堆，只适用于存储类、常量等相关信息！
   + 用来存放程序中永远不变或唯一的内容。（类信息【Class对象】、静态变量、字符串常量等）
5. ![Snipaste_2020-04-10_17-26-56](C:\Users\张辉\Desktop\Snipaste_2020-04-10_17-26-56.jpg)

### 构造方法（constructor）

1. 构造器也叫构造方法，用于对象的初始化。
2. 通过new关键字调用
3. 构造器虽然有返回值，但是不能定义返回值类型（返回值的类型肯定是奔类），`不能再构造器里使用return 返回某个值`(所以他不能被构造)。
4. 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果以定义则编译器不会自动添加。
5. 构造器的方法名必须和类名一致。
6. 构造器可以理解为帮助类进行初始化的方法。

#### 构造方法重载

+ 与普通方法一样，构造方法也可以重载。
+ 重载的使用与普通方法的重载一样。

### 垃圾回收机制（GC）

#### 内存管理

1. Java的内存管理很大程度值得就是对象的管理，其中包括对象空间的分配和释放。
2. 对象空间的分配：使用new关键字创建对象即可。
3. 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有“不可达”对象的内存空间。

#### 垃圾回收过程

1. 发现无用的对象。
2. 回收无用对象占用的内存空间。
3. 垃圾回收机制保证可以将“无用的对象”进行回收。无用对象值得就是没有任何变量引用该对象。

#### 垃圾回收算法

1. 引用计数法：

   + 堆中的每个对象都有一个引用计数。被引用一次，计数加1，被引用变量值为null，则计数减1.直到计数为0.

   + 缺点：“循环引用的无用对象”无法识别。

   + ```java
     s1.friend = s2;
     s2.friend = s1;    
     s1 = null;
     s2 = null;
     // s1和s2互相引用对方，导致他们引用计数不为0，但是实际已经无用，但无法被识别。
     ```

2. 引用可达法（根搜索算法）

   + 从开始第一个节点，寻找下一个节点；当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用的节点，即无用的节点。

#### 通用的分代垃圾回收机制

1.  新创建的对象，绝大多数都会存储在Eden中，

2. 当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉， 然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区。
3. 当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。
4. 重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中，
5. 当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）
6. 三个回收：
   + Minor GC：用于清理年轻代区域。
   + Major GC：用于清理老年代区域。
   + Full GC：用于清理年轻代、年老代。成本较高。
7.  持久代：用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。

#### JVM调优和Full GC 

1. JVM 调优的过程中很大一部分是对Full GC 的调节。
2. 导致Full GC 可能有以下原因：
   + 年老代（Tenured）被写满
   + 持久代（Perm）被写满
   + System.gc()被显式调用（程序建议启动GC，不是调用GC）
   + 上一次GC之后heap的各域分配策略动态变化

#### 内存泄漏

1. 创建了大量无用对象：拼接字符串时使用了String会造成。
2. 静态集合类的使用（HashMap,Vector,list）
3. 监视器的使用：释放对象时，没有删除相应的监视器。
4. 各种连接对象未关闭。

### this 关键字

1. this 的本质就是“创建好的对象的地址”！由于在构造方法调用前，对象已经创建。因此在构造方法中也可以使用this代表“当前对象”。
2. this 不能用于 static 方法中（static中对象还没有被创建好）。

### static 关键字

1. 在类中，static 声明的成员变量为静态成员变量。
2. 类变量的生命周期和类相同，在整个应用的执行期间都有效。
3. static 的变量为公用变量，属于类。被该类的所有实例共享，在类被载入时显式的初始化。
4. 一般使用“类名.类属性/方法”来调用。
5. static 方法中不可以直接访问`非static` 的成员。

### 参数传值机制

1. 基本数据类型参数的传值：传递的式值的副本。副本改变不会影响原件。
2. 引用类型参数传值：传递的式值的副本，但是引用类型值得是“对象的地址”。因此，副本和原参数都指向了同一个“地址”，所以说改变了副本的值也会改变原来的值。

### 静态初始化块

> 静态初始化块用于类的初始化操作（初始化时之）！在静态初始化块中不能直接访问static成员

### 静态导入

> 在jdk1.5增加的新功能，其作用是用于导入指定类的静态属性，这样我们就可以直接使用。

## 常用类

### 包装类

![image-20200411213327310](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200411213327310.png)

#### 包装类的用途

1. 作为和基本类型对应的类型存在，方便涉及到对象的操作。
2. 包含每种基本数据类型的相关属性如最大值，最小值等，以及相关的操作方法。

#### 自动装箱和拆箱

1. 自动装箱
   1. 基本类型的数据处于需要对象的环境中时，会自动转化为“对象”。
   2. `Integer i = 5` 在自动装箱中就相当于 `Integer i = Integer.valueOf(5)` 这样的操作，这就是Java的自动装箱
2. 自动拆箱
   1. 没有必要显式的调用intValue(),doubleValue()等转型方法。
   2. 如： `Integer i = 5;int j = i;` 这样的过程就是自动拆箱。
3. 包装类的空指异常
   1. 当 `Integer i = null;int j = i.intValue();`  这样就会造成空指异常。
   2. 因为 i 并没有指向任何对象的实体，所以就不可能操作 intValue()方法。

#### 包装类的缓存问题

1.  如果数据在-128~127这个区间，那么在类加载时就已经为该区间的每个数值创建了对象，并将这256个对象存放到一个名为cache的数组中。每当自动装箱过程发生时(或者手动调用valueOf()时)，就会先判断数据是否在该区间，如果在则直接获取数组中对应的包装类对象的引用，如果不在该区间，则会通过new调用包装类的构造方法来创建对象。 
2. IntegerCache类为Integer类的一个静态内部类，仅供Integer类使用。
3.  一般情况下 IntegerCache.low为-128，IntegerCache.high为127，IntegerCache.cache为内部类的一个静态属性

### String类

#### String

1. String类对象代表不可变的字符序列，因此我们可以将对象称为“不可变对象”。
2. String 类底层创建的数组是final的，也就是常量，只能被赋值一次。
3. String类常用的方法：
   1. 创建返回对象：concat(),replace(),substring(),toLowerCase(),toUpperCase(),trim(),
   2. 提供查功能：endsWith(),startsWith(),indexOf(),lastIndexOf()
   3. 提供比较功能的方法：equals(),equalsIgnoreCase(),compareTo().
   4. 其他方法：charAt(),length().

#### StringBuffer和StringBuilder

1. StringBuffer 线程安全，做线程同步检查，效率较低。
2. StringBuilder 线程不安全，不做线程同步检查，效率高。
3. 这俩的方法都是返回自己本身。
4.  append(…)  添加字符序列，仍然返回自身对象。 
5.  delete(int start,int end)   删除从start开始到end-1为止的一段字符序列，仍然返回自身对象 
6.  deleteCharAt(int index)    移除此序列指定位置上的 char，仍然返回自身对象 
7.  insert(…)   在指定位置插入字符序列，仍然返回自身对象 
8.  reverse()    用于将字符序列逆序，仍然返回自身对象。 
9.  toString() 返回此序列中数据的字符串表示形式 

### 时间类

>  JDK1.1之后，日期操作一般使用Calendar类，而字符串的转化使用DateFormat类。 

#### DateFormat类和SimpleDateFormat类

![image-20200411220720702](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200411220720702.png)

```java
// 把时间对象按照"格式字符串指定的格式"转成相应的字符串
DateFormat df = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
// SimpleDateFormat是DateFormat的一个子类
String str = df.format(new Date(40000000));
System.out.println(str);

// 把字符串按照“格式字符串指定格式”转成相应的时间对象
DateFormat df2 = new SimpleDateFormat("yyyy年MM月DD日 hh时mm分ss秒");
Date date = df2.parse("2020年04月07日 12时16分40秒");
System.out.println(date);

// 测试其他的格式字符。比如：利用D，获取本事件对象是所处年份的第几天。
DateFormat df3 = new SimpleDateFormat("D");
// SimpleDateFormat是DateFormat的一个子类
String str3 = df3.format(new Date());
System.out.println(str3);
```



#### Calendar日历类

>  GregorianCalendar 是 Calendar 的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。 

```java
public static void printCalendar(Calendar c) {
    // 打印：1918年10月10日 11：23：45 周三
    int year = c.get(Calendar.YEAR);
    int month = c.get(Calendar.MONTH) + 1;
    int date = c.get(Calendar.DAY_OF_MONTH);
    int dayweek = c.get(Calendar.DAY_OF_WEEK) - 1;
    String datweek2 = dayweek==0?"日":dayweek+"";

    int hour = c.get(Calendar.HOUR);
    int minute = c.get(Calendar.MINUTE);
    int second = c.get(Calendar.SECOND);

    System.out.println(year + "年" + month + "月" + date + "日" + hour + "时" + minute + "分" + second + "秒" + " 周" + datweek2);
}
```

### Math类

1. abs 绝对值

2. acos,asin,atan,cos,sin,tan 三角函数

3. sqrt 平方根

4. pow(double a, double b) a的b次幂

5. max(double a, double b) 取大值

6. min(double a, double b) 取小值

   7. ceil(double a) 大于a的最小整数

   8. floor(double a) 小于a的最大整数

9. random() 返回 0.0 到 1.0 的随机数
10. long round(double a) double型的数据a转换为long型(四舍五入)

11. toDegrees(double angrad) 弧度->角度

12. toRadians(double angdeg) 角度->弧度
13. java.lang.Math提供类一系列静态方法用于科学计算。

### File类

1.  java.io.File类：代表文件和目录。 在开发中，读取文件、生成文件、删除文件、修改文件的属性时经常会用到本类。 

2.  ```java
   File f = new File("d:/b.txt");
   f.renameTo(new File("D:/b.txt"));
   System.out.println("File是否存在："+f.exists());
   System.out.println("File是否是目录："+f.isDirectory());
   System.out.println("File是否是文件："+f.isFile());
   System.out.println("File最后修改时间："+new Date(f.lastModified()));
   System.out.println("File的大小："+f.length());
   System.out.println("File的文件名："+f.getName());
   System.out.println("File的目录路径："+f.getPath());
   ```

3. 关于文件操作的很多文件都在这个包中

### 枚举

1. 格式： `enum 枚举名 {枚举体（常量列表）}`

2. ```java
   enum` `Season {
     ``SPRING, SUMMER, AUTUMN, WINDER 
   }
   ```

3.  枚举实质上还是类!而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final修饰的。可以直接通过枚举类型名使用它们。 

## 异常机制

### 异常分类

1. Throwable分为Error和Exception.

#### Error

1. Error是程序无法处理的错误，是JVM出现的问题。
2. 大多数情况下重启虚拟机则可以解决。

#### Exception

1. RuntimeException 运行时异常
2. CheckedException 已检查异常
3. 抛出异常：throw
4. 捕获异常：try-catch

#### RuntimeException

1. 运行时异常包括：被0除，数组下标越界，空指针等。
2. 通常需要增加逻辑处理来避免这些异常。

#### CheckedException

1. 这就是我们在书写程序时遇到的错误。
2. 不处理，就不能通过编译。

#### try-catch-finally

1. 如果出现异常，可以通过catch来捕获异常并处理。
2. 最后一步的finally所指定的代码都要被执行。
3.  即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。 
4.   finally语句块只有一种情况是不会执行的，那就是在执行finally之前遇到了System.exit(0)结束程序运行。 

####  **throws** 

> 将当前遇到的异常传递给下一层处理。

### 自定义异常

```java
/**IllegalAgeException：非法年龄异常，继承Exception类*/
class IllegalAgeException extends Exception {
    //默认构造器
    public IllegalAgeException() {
     
    }
    //带有详细信息的构造器，信息存储在message中
    public IllegalAgeException(String message) {
        super(message);
    }
}
```

1. 要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。

2. 处理异常不可以代替简单测试---只在异常情况下使用异常机制。

3. 不要进行小粒度的异常处理---应该将整个任务包装在一个try语句块中。

4. 异常往往在高层处理 。

## 面向对象进阶

### 继承（extends）

+ 继承的意思即是对一个内容进行扩展构成一个新的内容。
+ 比如：动物可以继承扩展为哺乳动物和爬行动物；他们的底层都是相同的，但是总有一些不一样的地方。
+ Object类是所有Java类的根基类，也就是所有的Java对象都拥有Object类的属性和方法。

#### instanceof

1. `instanceof` 是二元运算符，左边是对象，右边是类

2. 当对象是右边类或子类所创建的对象时，返回true，否则false.

3. ```java
   // Student类是Person的一个子类
   Student s = new Student("zs",190,"c++");
   System.out.println(s instanceof Person);
   System.out.println(s instanceof Student);
   ```

#### 继承使用应注意的要点

1. 父类也成为超类、基类、派生类等。
2. Java中只有单继承（但是接口可以多继承）。多继承会引起会乱，是的继承链过于复杂，系统难于维护。
3. Java中类没有多继承，接口有多继承。
4. 子类继承父类，可以得到父类所有属性和方法（除了父类的构造方法），但不见得可以直接访问（父类的私有属性和方法）。
5. 在定义类是没有调用 extends ，则他的父类是： java.lang.Object

#### 方法的重写（override）

1. 重写的条件

   + 方法名和形参列表必须相同。
   + 返回值类型和声明异常类型，子类小于等于父类。
   + 访问权限，子类大于等于父类。

2. ```java
   public class TestOverride {
       public static void main(String[] args) {
           Vehicle v1 = new Vehicle();
           Vehicle v2 = new Horse();
           Vehicle v3 = new Plane();
           v1.run();
           v2.run();
           v3.run();
           v2.stop();
           v3.stop();
       }
   }
   class Vehicle { // 交通工具类
       public void run() {
           System.out.println("跑....");
       }
       public void stop() {
           System.out.println("停止不动");
       }
   }
   class Horse extends Vehicle { // 马也是交通工具
       public void run() { // 重写父类方法
           System.out.println("四蹄翻飞，嘚嘚嘚...");
       }
   }
    
   class Plane extends Vehicle {
       public void run() { // 重写父类方法
           System.out.println("天上飞！");
       }
       public void stop() {
           System.out.println("空中不能停，坠毁了！");
       }
   }  
   ```

3. 继承的方法在使用的时候，必须new.

4. new的时候可以使用 ` Vehicle v3 = new Plane(); ` ，但是在后边的对象转型的时候，必须注意（不能转错类型，因为一个父类可能存在多个子类）。

### 一些基础方法（toString,==,equals）

#### toString 

1. Object类中定义了 `public String toString()` 方法，其返回值是String类型的。
2. Object类中的toString方法是输出：类名+@+16进制的hashcode
3. 所以在一般使用中toString 方法一般都会被重写。

#### == 和 equals

1. `==` 海表比较双方是都夏姑娘同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等则为同一个对象。
2. `equals` 方法默认就是比较两个对象的hashcode，是同一个类型的引用时返回true。一般我们会重写equals方法。
3. JDK提供的很多类中都对equals方法进行类重写（重写之后一般都是比较内容值是否相等）。

### super关键字和继承树

1. super时直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。
2. 使用super调用普通方法，语句没有位置限制，可以在子类中随便调用。
3. super()方法构造函数都会默认调用。

4. 继承方法使用的时候会向上寻找我们的调用（继承树回溯）。

### 封装

+ 提高代码的安全性
+ 提高代码的复用性
+ “高内聚”：封装细节，便于修改内部代码，提高可维护性。
+ “低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。

#### 访问控制

1. `private ` 表示私有，只有自己类能访问 
   + 只能在自己的类中使用，其他地方都不能使用
   + 使用范围：同一个类（一个类就是一个.java中的一个class）
2. `default` 表示没有修饰符修饰，只有同一个包的类能访问
   + 在变量或者方法没有被修饰的情况下默认为 default 的，这样就最大就只能在同一个包中使用
   + 使用范围：同一个类，同一个包(一个包就是package中)
3. `protected` 表示可以被同一个包的类以及其他包中的子类访问(好像不太经常使用)
   + 在被 protected 修饰的情况下，变量或者方法就最多被继承它的子类所使用。
   + 使用范围：同一个类，同一个包，它的子类(使用 extends 继承了它的子类，这儿的继承也就只能在同一个)
4. `public` 表示可以被该项目的所有包中的所有类访问

#### 封装的细节

1. 一般使用 `private` 访问权限
2. 提供相应的 get/set 方法来访问相关属性，这些方法通常是public的。
3. boolean 变量的 get 方法是 is 开头的。
4.  一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰。 

### 多态（polymorphism）

1. 多态是方法的多态，不是属性的多态

2. 多态的存在有三个必要条件：继承，方法重写，父类引用指向子类对象。

3. 父类引用指向子类对象后，该父类引用调用子类重写的方法，此时多态就出现了。

4. 简单来说，多态就是多个子类继承同一个父类，然后对父类中的某个方法都进行了重写（override）。这样就构成了多态。

5. ```java
   // 有了多态，只需要让增加的这个类继承Animal类就可以了。
   static void animalCry(Animal a) {
       a.shout();
   }
   ```

6. 不管是什么动物叫，我们只要把对象传进去，就能发出准确的叫声。

### 对象的转型(casting)

1. 父类引用指向子类对象，我们成这个过程为向上转型，属于自动类型转换。
2. 向上转型后的父类引用变量只能调用他编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要强制转型，称之为向下转型。
3. 类型转换时应该注意异常的处理。

### final关键字

1. final修饰的变量不能被二次赋值。
2. final修饰的方法，不能被重写。
3. final修饰的类不能被继承。

### 抽象方法和抽象类（abstract）

#### 抽象方法

+ 使用abstract修饰的方法，没有方法体，只有声明。
+ 定义的是一种规范，告诉子类必须要给抽象方法提供具体的实现。

#### 抽象类

+ 包含抽象方法的类就是抽象类。
+  通过abstract方法定义规范，然后要求子类必须定义具体实现 
+  通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。 

#### 抽象类使用要求

1. `抽象方法的类只能定义成抽象类。`
2. 抽象类不能实例化，也就是不能用 `new` 来实例化抽象类。
3. 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来 `new` 实例，只能用来被子类调用。
4. 抽象类只能用来被继承。
5. 抽象方法必须被子类实现。

### 接口（interface）

+ 普通类：具体实现
+ 抽象类：具体实现，规范（抽象方法）。
+ 接口：规范

#### 接口的定义

1. 声明格式：

   ```java
   [访问修饰符]  interface 接口名   [extends  父接口1，父接口2…]  {
   常量定义；  
   方法定义；
   }
   ```

2. 访问修饰符：只能时public或者默认（default）。

3. 接口名：和类名采用相同的命名机制；首字母大写和驼峰原则；

4. extends：接口可以多继承，但是 `继承的都是接口` 。

5. 常量：接口中的属性只能是常量，总是 `public static final` 修饰的，不写也是如此。

6. 方法：接口中的方法只能是 `public abstract` ，省略的话也是 `public abstract` ，也就意味着方法是抽象的，只需要规范即可，不需要实现。

#### 接口的使用

1. 子类通过 `implements` 来实现接口中的规范。

2. 接口不能创建实例，但是可用于声明引用变量类型。

3. 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是 `public` 的。

4. 在JDK1.8后，接口中包含了静态常量，抽象方法，静态方法。不能有普通属性，构造方法。

5. ```java
   public class TestInterface {
       public static void main(String[] args) {
           Volant volant = new Angel();
           volant.fly();
           System.out.println(Volant.FLY_HIGHT);
            
           Honest honest = new GoodMan();
           honest.helpOther();
       }
   }
   /**飞行接口*/
   interface Volant { 
       int FLY_HIGHT = 100;  // 总是：public static final类型的；
       void fly();   //总是：public abstract void fly();
   }
   /**善良接口*/
   interface Honest { 
       void helpOther();
   }
   /**Angle类实现飞行接口和善良接口*/
   class Angel implements Volant, Honest{
       public void fly() {
           System.out.println("我是天使，飞起来啦！");
       }
       public void helpOther() {
           System.out.println("扶老奶奶过马路！");
       }
   }
   class GoodMan implements Honest {
      public void helpOther() {
           System.out.println("扶老奶奶过马路！");
       }  
   }
   class BirdMan implements Volant {
       public void fly() {
           System.out.println("我是鸟人，正在飞！");
       }
   }
   ```

#### 接口的多继承

```java
interface A {
    void testa();
}
interface B {
    void testb();
}
/**接口可以多继承：接口C继承接口A和B*/
interface C extends A, B {
    void testc();
}
public class Test implements C {
    public void testc() {
    }
    public void testa() {
    }
    public void testb() {
    }
}
```

### 内部类

#### 非静态/静态内部类

```java
public class TestInnerClass {
    public static void main(String[] args) {
        Outer outer = new Outer();
        /**
         * 上边是创建外部类
         * 下边创建内部类
         *
         * 非静态内部类可以直接访问外部类成员，但是外部类不能访问非静态内部类的成员
         * 非静态内部类不能有静态方法、静态属性和静态初始化块。
         * 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。
         */
        
        // 创建非静态内部类
        Outer.Inner inner = new Outer().new Inner();
        inner.show();
        
        // 创建静态内部类，静态内部类不依托于外部类
        Outer2.Inner2 inner = new Outer.Inner2();
    }
}
class Outer {
    private int age = 10;

    public void testOuter() {
        System.out.println("Outer.testOuter");
    }

    class Inner {
        int age = 20;
        public void show() {
            int age = 30;
            System.out.println("外部类的成员变量age:" + Outer.this.age);
            System.out.println("内部类的成员变量age:" + this.age);
            System.out.println("局部变量age:" + age);
        }
    }
    static class Inner2{
    }
}
```

#### 匿名内部类

1. 语法： `new 父类构造器（实参类表）\实现接口 () { 匿名内部类类体 }`

2. 匿名内部类只使用一次。

3. ```java
   public class TestAnnonymousInnerClass {
   
       public static void test01(A a){
           System.out.println("ajd");
           a.aa();
       }
       public static void main(String[] args) {
           TestAnnonymousInnerClass.test01(new A() {
               @Override
               public void aa() {
                   System.out.println("Test");
               }
           });
       }
   }
   interface A{
       void aa();
   }
   ```

### String 基础

>  String类是不可变字符串，方法在之前写了。

#### String常用方法

![image-20200413000210787](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200413000210787.png)

### 常量池

#### 全局字符串常量池（String Pool）

> 存放的内容是类加载完成后存到String Pool中的，每个VM只有一份，存放的是字符串常量的引用值。

#### class文件常量池（Class Constant Pool）

> class常量池是在编译的时候每个class都有的，在编译阶段存放的是常量（文本字符串、final常量等）和符号的引用。

#### 运行时常量池（Runtime Constant Pool）

>  运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。 

## 容器

### 泛型（Generics）

1. 泛型是JDK1.5之后增加的，它可以给我们建立类型安全的集合。
2. 在使用了泛型的集合中，遍历时不必进行强制类型转换。
3. 泛型的本质就是“数据类型的参数化”。
4. 我们可以把泛型理解为数据类型的一个占位符。

#### 自定义泛型

1. 声明：在类的声明处增加泛型列表，如：<T,E,V>.

2. 泛型的使用 

3.  ```java
   class MyCollection<E> {// E:表示泛型;
       Object[] objs = new Object[5];
    
       public E get(int index) {// E:表示泛型;
           return (E) objs[index];
       }
       public void set(E e, int index) {// E:表示泛型;
           objs[index] = e;
       }
   }
   public class TestGenerics {
       public static void main(String[] args) {
           // 这里的”String”就是实际传入的数据类型；
           MyCollection<String> mc = new MyCollection<String>();
           mc.set("aaa", 0);
           mc.set("bbb", 1);
           String str = mc.get(1); //加了泛型，直接返回String类型，不用强制转换;
           System.out.println(str);
       }
   }
   ```

### Collection接口

+ Collection 表示一组对象，它是集中、收集的意思。
+ Collection 接口的两个子接口是 List 、Set 接口。
+ 由于List 、Set是Collection 的子接口，意味着所有的List、Set的实现类都有下面的方法。
+ ![image-20200414101159884](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200414101159884.png)

### List 

1. List是`有序`、`可重复`的容器
2. 有序：List 中每个元素都有索引表记。可以根据元素的索引标记（在List中的位置）访问元素，从而精确控制这些元素。
3. 可重复：List 允许加入重复的元素。List 通常允许满足 e1.equals(e2) 的元素重复加入容器。
4. List 不仅继承了 Collection的所有方法，还有以下方法：![image-20200414101714526](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200414101714526.png)

5. List 有三个实现类： ArrayList，LinkedList和Vector
6. ArrayList：底层使用数组实现的存储。特点：查询效率高，增删效率低，线程不安全。（虽然不安全，但是我们使用它。）
   + 数组扩容是使用： `int newCapacity = oldCapacity + (oldCapacity >> 1) `
7. LinkedList：底层用双链表实现的存储。特点：查询效率低，删除效率高，线程不安全。
8. Vector：底层使用的数组（实现过程都使用ArrayList的实现方法）实现了List，但是相关方法都加了同步检查，因此“线程安全，效率低”。
   + 所有实现都增加了 `synchronized` 

#### 如何选用 ArrayList,LinkedList,Vector

1. 需要线程安全时，用Vector。
2. 不存在线程安全问题时，并且查找较多用ArrayList（一般使用它）。
3. 不存在线程安全问题时，增加或删除元素较多用LinkedList.

### Map接口

1. Map就是用来存储“键(key)-值(value)对”的。
2. Map 类中存储的“键值对”通过键来标识，所以“键对象”不能重复。
3. Map接口的实现类有 HashMap,TreeMap,HashTable,Properties等。
4. Map接口中常用的方法![image-20200414140041796](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200414140041796.png)

#### HashMap和HashTable

1. HashMap 次啊用哈希算法实现，是Map接口最常用的实现类。
2. HashMap 底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对替换旧的键值对。
3. HashMap继承了ArrayList和LinkedList的优点，在查找、删除、修改方面都有非常高的效率。
4. HashTable类和HashMap用法几乎一样，底层实现几乎一样，只不过HashTablede的添加了 `synchronized` 关键字确保线程同步检查，效率较低。
5. HashMap：线程不安全，效率高。允许key或value为null.
6. HashTable：线程安全，效率低。不允许key或value为null.

#### HashMap底层

1. HashMap底层实现采用了哈希表，这是一种非常重要的数据结构。
2. 数组：占用空间连续。寻址容易，查询速度快。但是，增加和删除效率非常低。
3. 链表：占用空间不连续。寻址困难，拆线呢速度慢。但是，增加和删除效率非常高。
4. HashMap结合了数组和链表的优点（数组+链表）。

5. `resize` 利用扩展因子（ loadFactor ），默认情况下扩展因子为0.75；每当hashmap中的元素个数超过当桶位元素的个数的0.75倍时，就会将数组大小扩大一倍。hashmap的大小是2的倍数。
6. hashmap结构：hash|key|value|next
7. hashcode使用 `value&length-1`
8. 在JDK8中，对应链表长度大于8时，链表就会转换为红黑树，这样大大提高了查找的效率。

## IO流

1. 对于程序设计来说，输入输出（Input/Output）系统是非常核心的功能。
2. 输入（Input）指的是：可以让程序从外部系统获得数据（核心含义是“读”，读取外部数据）。
3. 输出（Output）指的是：将程序获取到的数据输出到外部。

### 文件相关知识

#### 1. 文件的路径

```text
1. 文件的路径一般表示为: "C:/Users/zs/Desktop/th.jpg";
2. 在Windows中文件的路径表示为: "C:\Users\zs\Desktop\th.jpg"
3. 在我们的编译中"\"作为转义字符使用,所以我们一般会用"\\"表示我们的"\".
4. 除过斜杆拼接,我们在Java中还有"File.separator"可以作为拼接常量,供我们使用.
```

#### 2. 构建文件对象

 ```java
String path = "C:/Users/zs/Desktop/th.jpg";
File src = new File(path); 
// 通过字符串对象的路径构建File对象
src = new File("C:/Users/zs/Desktop/th.jpg");
// 直接通过字符串的路径构建File对象
src = new File(new File("C:/Users/zs/Desktop/"),"th.jpg");
// 首先确定要构造文件目录的对象,然后再确定相对应的文件.

 ```

#### 3. 相对路径与绝对路径

```java
// 从文件根路径开始的路径就是绝对路径
// 不是从文件根路径开始的路径就是相对路径
File src = new File(path);
src.getAbsolutePath();
// 获取文件的绝对路径
System.getProperty("user.dir");
// 获取项目的相对路径
```

#### 4. 获取文件的名称和路径

```java
src.getName(); //获取文件的名称
src.getPath(); //获取文件的路径
src.getAbsolutePath(); //获取文件的绝对路径
src.getParent(); //获取文件的父节点
src.getParentFile(); //获取文件的父对象 
```

#### 5. 获取文件的状态

```java
src.exists(); // 判断文件是否存在
src.isFile(); // 判断是否文件
src.isDirectory(); //判断是否文件夹

// 文件状态判断的完整操作
src = new File("xxx");
if (src == null || !src.exists()) {
    // 文件不存在
} else {
    if (src.isFile()) {
        // 文件操作
    } else {
        // 文件夹操作
    }
}
```

#### 6. 文件的长度

```java
src.length(); // 获取文件的长度(大小)
// 注意:只能获取文件的长度,不能获取整个文件夹的大小
```

#### 7. 创建/删除文件

```java
File src = new File("C:/Users/zs/Desktop/th.txt");
boolean flag = src.createNewFile();
// 创建文件,不存在才创建,创建成功返回true
flag = src.delete();
// 删除文件,删除成功,返回true
// 再创建文件时要注意:con con3... 操作系统的设备名,不能正确的创建.
```

#### 8. 创建文件夹

```java
// 1. mkdir():确保上级目录存在,不存在创建失败
// 2. mkdirs():上级目录可以不存在,不存在创建失败
// 都是通过返回boolean值来表示文件夹是否创建成功
File dir = new File("F:/IDEA_project/Java300/dir/test");
boolean flag = dir.mkdirs();
flag = dir.mkdir();
```

#### 9. 列出目录的下一级

```java
// list():列出下级名称
// listFiles():列出下级File对象,这儿可以得到下一级文件夹/文件的对象
String[] subNames = dir.list();
File[] subFiles = dir.listFiles();
```

#### 10. 文件的解码/编码

```java
// decode 解码 :  字节数组-->字符串
msg = new String(dates,0,datas.length,"UTF-8");
// encode 编码 :  字符串-->字节数组
byte[] datas = msg.getBytes();
```

#### 11. 乱码

1. 字节数不够:在使用 `new String(dates,0,datas.length,"UTF-8")` 解码的时候 `date.length-1` 长度缺失
2. 字符集不统一:使用的编码字符集不同,就会造成这种问题: `UTF-8或者GBK字符集`

### 数据源(data source)

1. 数据源分为：源设备、目标设备。
2. 源设备(src)：为程序提供数据，一般对应输入流。
3. 目标设备(dest)：程序数据的目的地，一般对应输出流。

### 流(stream)

1. 流是一个抽象、动态的概念，是一连串连续动态的数据集合。
2. 输入流：我们通过流(Stream)将数据源(Source)中的数据(information)输送到程序(program)中。
3. 输出流：目标数据就是目的地(dest)，我们通过流(Stream)将程序(Program)中的数据(information)输送到目的数据源(dest)中。
4. 输入流/输出流的划分并不是相对数据源的，是相对程序而言的。

### IO标准步骤

1. 创建源
2. 选择流
3. 操作
4. 释放资源（先打开的后释放）
5. 标准代码

```java
import java.io.*;
/**
 * 这是输入流
 * @auther 张辉
 */
public class IOStreamStandard{
    public static void main(String[] args) {
        // 1. 创建源
        File src = new File("abc.txt");
        // 2. 选择流
        Reader reader = null;
        try {
            reader = new FileReader(src);
            
            // 3. 操作（读取）
            char[] flush = new char[1024];
            // 缓冲容器
            int len = -1;
            // 接收长度
            while ((len = reader.read(flush)) != -1) {
                // 字符数组到字符串
                String str = new String(flush, 0, len);
                System.out.println(str);
            }
        } catch (FileNotFoyundException e) {
            e.printStackTrace();  
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 释放资源
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### Java中流的概念细分

#### 按流的方向分类

1. 输入流：数据流向是数据源到程序（以InputStream、Reader结尾的流）。
2. 输出流：数据流向是程序到目的地（以OutputStream、Write结尾的流）。

#### 按处理的数据单元分类

1. 字节流：以字节为单位获取数据，命名以上Stream结尾的流一般是字节流，如：FileInputStream、FileOutputStream。
2. 字符流：以字符为单位获取数据，命名上以Reader/Writer结尾的流一般是字符流，如：FileReader、FileWriter。

#### 按处理对象不同分类

1. 节点流：可以直接从数据源或目的地读写数据，如：FileInputStream、FileReader、DataInputStream等。
2. 处理流：不直接连接到数据源或目的地，是”处理流的流“。通过对其他流的处理提高程序的性能，如BufferedInputStream、BufferedReader等。处理流也叫包装流。
3. 节点流初于IO操作的第一线，所有操作必须通过他们进行；处理流可以对节点进行包装，提高性或提高程序的灵活性。

![image-20200505155826673](C:\Users\张辉\AppData\Roaming\Typora\typora-user-images\image-20200505155826673.png)

### Java中IO流类的体系

1.  `InputStream/OutputStream` : 字节流的抽象类
2.  `Reader/Writer` :字符流的抽象类
3.  `FileInputStream/FileOutputStream` 
   + 节点流 : 以字节为单位直接操作"文件".
4.  `ByteArrayInputStream/ByteArrayOutputStream` 
   + 节点流 : 以字节为单位直接操作"字节数组对象".
5.  `FileReader/FileWriter`
   + 节点流 : 以字符为单位直接操作"文本文件" (注意 : 只能读写文本文件).
6.  `ObjectInputStream/ObjectOutputStream`
   + 处理流 : 以字节为单位直接操作"对象".
7.  `DataInputStream/DataOutputStream`
    + 处理流 : 以字节为单位直接操作"基本类型与字符串类型".
8.   `BufferedReader/BufferedWriter`
    + 处理流 : 将 `Reader/Writer` 对象进行包装,增加缓存功能 ,提高读写效率.
9.   `BufferedInputStream/BufferedOutputStream`
    + 处理流 : 将 `InputStream/OutputStream` 对象进行包装,增加缓存功能(一般缓存8k),提高读写效率.
10.   `InputStreamReader/OutputStreamWriter`
     + 处理流 : 将字节对象转化成字符流对象.
11.   `PrintStream`
     + 处理流 : 将 `OUtputStream` 进行包装,可以方便地输出字符,更加灵活.

### 四大IO抽象类

> `InputStream/OutputStream和Reader/Writer` 类是所有IO流类的抽象父类.

#### InputStream

1. 此抽象类是标识字节输入流的所有类的父类.
2. `InputStream` 是一个抽象类,他不可以实例化.
3. 继承自 `InputStream` 的流都是用于向程序中输入数据,且数据的单位为字节(8 bit).
4. 常用方法:
   + int read() : 读取一个字节的数据,并将字节的值作为int类型返回(0-255之间的一个值).如果未读出字节则返回 -1 (返回值为 -1 表示读取结束)
   + void close() : 关闭输入流对象,释放相关系统资源.

#### OutputStream

1. 此抽象类是表示字节输出流的多有类的父类.
2. 输出流接收输出字节并将这些字节发送到某个和目的地.
3. 常用方法:
   + void writer(int n) : 向目的中写入一个字节.
   + void close() : 关闭输出流对象,释放相关资源.

#### Reader

1. Reader用于读取的字符流抽象类,数据单位为字符.
2. int read() : 读取一个字符的数据,并将字符的值作为int类型返回(0-65535之间的一个值,即 Unicode 值).如果未读出字符则返回 -1 (返回值为 -1 表示读取结束)
3. void close() : 关闭流对象,释放相关资源.

#### Writer

1. Writer用于写入的字符流抽象类,数据单位为字符.
2. void writer(int n) : 向输出流中写入一个字符.
3. void close() : 关闭输出流对象,释放相关资源.

### 文件字节流

1. `InputStream/OutputStream` 
2. 为了减少对硬盘的读写次数,提高效率,通常设置缓存数组.相应地,读取时使用的方法为: `read(byte[] b)` ;写入时方法为: `write(byte[] b,int off,int length)`
3. 程序中如果遇到多个流,每个流都要单独关闭,防止防止其中一个流出现异常后导致其他流无法关闭的情况.
4. 在关闭多个流的时候,先打开的后关闭.

#### 文件字节输入流

> `InputStream/FileInputStream` 文件字节输入流 

```java
import java.io.*;

public class InputStreamZh{
    public static void main(String[] args) {
        // 1. 创建源
        File src = new File("abc.txt");
        // 2. 选择流
        InputStream is = null;
        try {
            is = new FileInputStream(src);
            // 3. 操作(读取)
            byte[] flush = new byte[1024];
            // 缓冲容器
            int len = -1;
            // 接收长度
            while ((len = is.read(flush)) != -1) {
                String str = new String(flush,0,len);
                System.out.println(str);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 释放资源(字节输入流可以不用释放,GC会帮我们处理,但是最好还是自己来关闭流,因为GC的回收是不确定的)
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOExcrption) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 文件字节输出流

> `OutputStream/FileOutputStream` 文件字节输出流(在输出流中都需要 `flush()` ),使用 `byte[]`

```java
import java.io.*;

public class OutputStreamZh{
    public static void main(args) {
        // 1. 创建源
        File dest = new File("dest.txt");
        // 2. 选择流
        OutputStream os = null;
        try {
            os = new FileOutputStream(dest,true);
            // 这儿的true,决定了文件是覆盖写入还是append.
            // 3. 操作
            String msg = "I am groot";
            byte[] datas = msg.getBytes();
            os.write(datas,0,datas.length);
            os.flush();
            // 刷新,防止文件内容驻留
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 释放资源
            try {
                if (os != null) {
                    os.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 文件字节拷贝流

> 利用文件字节流实现文件的复制

```java
import java.io.*;

/**
 * @auther 张辉
 * @Description 文件字节流复制的类
 */
public class CopyUtilsByte {
    private File src;
    private File dest;
    private int size = 1024 * 10;
    
    public CopyUtilsByte(String src, String dest) {
        this.src = new File(src);
        this.dest = new File(dest);
    }

    public CopyUtilsByte(String src, String dest, int size) {
        this.src = new File(src);
        this.dest = new File(dest);
        this.size = size;
    }

    public CopyUtilsByte(File src, File dest) {
        this.src = src;
        this.dest = dest;
    }

    public CopyUtilsByte(File src, File dest, int size) {
        this.src = src;
        this.dest = dest;
        this.size = size;
    }
    
    private void copy() {
        try (InputStream is = new FileInputStream(src);
             OutputStream os = new FileOutputStream(dest);) {
            byte[] flush = new byte[this.size];
            int len = -1;
            while ((len = is.read(flush)) != -1) {
                os.write(flush,0,len);
            }
            os.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 文件字符流

>  文件字节流可以处理所有的文件，但是字节流不能很好的处理Unicode字符，经常会出现“乱码”现象。所以，我们处理文本文件，一般可以使用文件字符流，它以字符为单位进行操作。 

#### 文件字符输入流

> `Reader/FileReader`

```java
import java.io.*;
public class ReaderZh {
    public static void main(String[] args) {
        File src = new File("abc.txt");
        Reader reader = null;
        try (){
            reader = new FileReader(src);
            
            char[] flush = new char[1024];
            int len = -1;
            while((len = reader.read(flush)) != -1) {
                System.out.println(new String(flush,0,len));
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 文件字符输出流

> `Writer/FileWriter`

```java
import java.io.*
public class WriterZh {
    public static void main(String[] args) {
        File dest = new File("dest.txt");
        Writer writer = null;
        try {
            writer = new FileWriter(dest);
            // 写法一
            //String msg = "I am anglue\t嘀哒哒";
            //char[] datas = msg.toCharArray();
            // 字符串到字符数组（编码）
            //writer.write(datas,0,datas.length);
            //writer.flush();

            // 写法二
            //String msg = "I am anglue\t嘀哒哒";
            //writer.write(msg,0,msg.length());
            //weiter.write("~~~~~~~~~");
            //writer.flush();

            // 写法三
            writer.append("I am anglue\\t").append("嘀哒哒~~~~~~~~~~~~");
            writer.flush();

        }catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (writer!=null) {
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
    }
}

```

#### 文件字符拷贝流

> 利用文件字符流实现文件的拷贝

```java
import java.io.*;

/**
 * @auther 张辉
 * @Description 文件字符流复制的类
 */
public class CopyUtilsChar {
    private File src;
    private File dest;
    private int size = 1024;

    public CopyUtilsChar(String src, String dest) {
        this.src = new File(src);
        this.dest = new File(dest);
        Math s;
    }

    public CopyUtilsChar(String src, String dest, int size) {
        this.src = new File(src);
        this.dest = new File(dest);
        this.size = size;
    }

    public CopyUtilsChar(File src, File dest) {
        this.src = src;
        this.dest = dest;
    }

    public CopyUtilsChar(File src, File dest, int size) {
        this.src = src;
        this.dest = dest;
        this.size = size;
    }

    private void copy() {
        try (Reader reader = new FileReader(src);
             Writer writer = new FileWriter(dest)) {
            char[] flush = new char[size];
            int len = -1;
            while ((len = reader.read(flush)) != -1) {
                writer.write(flush, 0, len);
            }
            writer.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 字节数组流

> `ByteArrayInputStream/ByteArrayOutputStream` 经常用在需要流和数组之间转化的情况。用人话说：FileInputStream是把文件当作数据源。ByteArrayInputStream则是把内存中的“某个字节数组对象”当作数据源。这个数据源是存在内存中的，所以不能太大。这两个流是新增的方法，不要使用InputStream. 字符数组流不用关闭，（GC会自动处理，如果你提出了关闭，也只是一个建议。）

#### 字节数组输入流

> `ByteArrayInputStream`

```java
import java.io.*;
public class ByteArrayInputStreamZh {
    public static void main(String[] args) {
        byte[] src = "I am groot".getBytes();
        ByteArrayInputStream bais = null;
        try {
            bai = new ByteArrayInputStream(src);
            byte[] flush = new byte[16];
            int len = -1;
            while ((len = bais.read(flush)) != -1) {
                System.out.println(new String(flush, 0, len));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bai != null) {
                    bais.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 字节数组输出流

> `ByteArrayOutputStream`

```java
import java.io.*;
public class ByteArrayOutputStreamZh {
    public static void main(String[] args) {
        // 这是输出
        byte[] dest = null;
        // 选择流
        ByteArrayOutputStream baos = null;
        try {
            baos = new ByteArrayOutputStream();
            String msg = "I am groot";
            // 数据源
            byte[] datas = msg.getBytes();
            baos.write(datas,0,datas.length);
            baos.flush();
            
            dest = baos.toByteArray();
            System.out.println(new String(dest,0,baos.size()));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } cathc (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (baos != null) {
                    baos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 字节数组拷贝文件

```java
import java.io.*;
public class IOTest09 {
    public static void main(String[] args) {
        byte[] datas = fileToByteArray("01.png");
        System.out.println(datas.length);
        byteArrayToFile(datas,"02.png");
    }

    /**
     * 1. 图片读取到字节数组
     * 1.1 图片到程序 FileInputStream
     * 1.2 程序到字节数组 ByteArrayOutputStream
     * @param filePath
     * @return byte[]
     */
    public static byte[] fileToByteArray(String filePath){
        // 1. 创建源与目的地
        File src = new File(filePath);
        byte[] dest = null;
        // 2. 选择流
        InputStream is = null;
        ByteArrayOutputStream baos = null;
        try {
            is = new FileInputStream(src);
            baos = new ByteArrayOutputStream();

            // 3. 操作（读取）
            byte[] flush = new byte[1024*10];
            // 缓冲容器
            int len = -1;
            // 接收长度
            while ((len = is.read(flush)) != -1) {
                baos.write(flush, 0, len);
                // 写出到字节数组中
            }
            baos.flush();
            // 刷新，放置驻留
            return baos.toByteArray();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 释放资源
            try {
                if (baos != null) {
                    baos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return null;
    }

    /**
     * 2. 字节数组写出到文件
     * 2.1 字节数组写出到程序 ByteArrayInputStream
     * 2.2 程序写出到文件 FileOutputStream
     * @param src
     * @param filePath
     */
    public static void byteArrayToFile(byte[] src,String filePath){
        // 1. 输出源
        File dest = new File(filePath);
        // 2. 选择流
        InputStream is = null;
        OutputStream os = null;
        try {
            is = new ByteArrayInputStream(src);
            os = new FileOutputStream(dest);
            // 3. 操作（读取）
            byte[] flush = new byte[5];
            // 缓冲容器
            int len = -1;
            // 接收长度
            while ((len = is.read(flush)) != -1) {
                os.write(flush,0,len);
                os.flush();
            }


        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 4. 释放资源
            try {
                if (os!=null) {
                    os.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (is != null) {
                    is.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}
```

### 缓冲字节流

1. `BufferedInputStream/BufferedOutputStream` ，缓冲流用人话来说：就是在字节流/字符流的外边套一个缓冲区，不必每个都输出, 因此缓冲流是一种处理流(包装流)。 
2.  在关闭流时，应该先关闭最外层的包装流，即“后开的先关闭” 
3.  缓存区的大小默认是8192字节(8K)，也可以使用其它的构造方法自己指定大小。 
4. 主要是缓冲流可以提高IO操作时的性能。

```java
import java.io.*;
public class Buffered{
    public void copy(String strPath, String destPath) {
        // 1. 创建流
        File src = new File(strPath);
        // 源头
        File dest = new File(destPath);
        // 目的地

        // 2. 选择流

        try (InputStream is = new BufferedInputStream((new FileInputStream(src)));
             OutputStream os = new BufferedOutputStream(new FileOutputStream(dest))) {

            // 3. 操作
            byte[] flush = new byte[1024];
            // 缓冲容器
            int len = -1;
            // 接受长度：当输入流到了末尾是，会返回-1
            while ((len = is.read(flush)) != -1) {
                // 上边分段读取
                // 下边分段写入
                os.write(flush, 0, len);
            }
            os.flush();
            // 刷新，放置驻留
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```

### 缓冲字符流

1. `BufferedReader/BufferedWriter` 
2.  BufferedReader/BufferedWriter增加了缓存机制，大大提高了读写文本文件的效率，
3. 同时，提供了更方便的按行读取的方法：readLine(); 处理文本时，我们一般可以使用缓冲字符流。 
4.  readLine()方法是BufferedReader特有的方法，可以对文本文件进行更加方便的读取操作。 
5.  `写入`一行后要记得使用newLine()方法换行。 

```java
import java.io.*;

/**
 * @author 张辉
 * @Description 纯文本拷贝
 * @create 2020-04-26 20:29
 */
public class CopyTxt {
    public static void main(String[] args) {
        copyTxt("abc.txt","dest.txt");
    }

    public static void copyTxt(String strPath,String destPath){
        // 1. 创建流
        File src = new File(strPath);
        //源头
        File dest = new File(destPath);
        // 目的地

        // 2. 选择流

        try (BufferedReader br = new BufferedReader((new FileReader(src)));
             BufferedWriter bw = new BufferedWriter(new FileWriter(dest))) {

            String line = null;

            // 接受长度：当输入流到了末尾是，会返回-1
            while ((line = br.readLine())!=null) {
                bw.write(line);
                // 逐行写出
                bw.newLine();
            }
            bw.flush();
            // 刷新，放置驻留
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 数据流

1. 数据流将“基本数据类型与字符串类型”作为数据源，从而允许程序以与机器无关的方式从底层输入输出流中操作Java基本数据类型与字符串类型。
2. `DataInputStream/DataOutputStream` 是处理流，可以对其他节点流或处理流进行包装，增加一些更灵活、更高效的功能。
3. `DataInputStream/DataOutputStream` 提供了可以存取与机器无关的所有Java基础类型数据（如：int、double、String等）的方法。
4. 数据流的写入和读出顺序必须相同

```java
import jva.io.*;
public class DataZh{
    public static void main(String[] args) throws IOException {
        // 写出
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        // 字节数组流不用关闭。（GC会自动处理，如果你提出了关闭的指令，也只是提出一个建议而已）
        DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(boas));
        dos.writerUTF("这是String串！");
        dos.writerInt(18);
        dos.writerBoolean(true);
        dos.writerChar('a');
        dos.flush();
        // 只要是OutputStream/Writer都必须flush()，防止数据驻留
        
        byte[] datas = baos.toByteArray();
        System.out.println(datas.length);
        
        // 读取
        DataInputStream dis = new DataInputStream(new BufferedInputStream(new ByteArrayInputStream(datas)));
        String msg = dis.readUTF();
        int age = dis.readInt();
        boolean flag = dis.readBoolean();
        char ch = dis.readChar();
        // 在这儿关闭流，先打开的后关闭
    }
}
```

### 对象流

1. 对象流在处理的时候，如果是自己写的类必须有`Serializable` ，又序列化标志的才能处理。
2. 对象流就是对对象进行读写操作的，`ObjectInputStream/ObjectOutputStream`。
3. `ObjectInputStream/ObjectOutputStream`是以“对象”未数据源，但是必须将传输的对象进行序列化与反序列化操作。
4. 并不是所有对象都可以序列化；要序列化必须 `implements java.io.Serializable`

```java
import java.io.*;
import java.util.Date;
public class ObjectZh{
    public static void main(String[] args) throws IOException,ClassNotFoundException{
        // 写出（序列化：serialization）
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        // 字节数组流可以不用关闭。（GC会自动处理，如果你提出了关闭的要求，也只是一个建议，建议总是好的）
        ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(baos));
        oos.writerUTF("这是一个字符串！");
        oos.writerInt(18);
        oos.writerBoolean(false);
        oos.writerChar('a');
        
        // 对象
        oos.writerObject("这是一个对象，也是一个串，串也是对象!");
        oos.writerObject(new Date());
        
        Employee emp = new Employee("zhangsan",40000);
        oos.writerObject(emp);
        oos.flush;
        
        byte[] datas = new baos.toByteArray();
        System.out.println(datas.length);
        
        // 读取（反序列化：deserialization）
        ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(new ByteArrayInputStream(datas)));
        // 写出与读取的顺序必须一致
        String msg = ois.readUTF();
        int age = ois.readInt();
        boolean flag = ois.readBoolean();
        char ch = ois.readChar();
        Object str = ois.readObject();
        Object date = ois.readObject();
        Object employee = ois.readObject();
        
        if (str instanceof String) {
            String strObj = (String)str;
            System.out.println(strObj);
        }
        
        if (date instanceof Date) {
            Date dateObj = (Date)str;
            System.out.println(dateObj);
        }
        
        if (employee instanceof Employee) {
            String empObj = (Employee)employee;
            System.out.println(empObj.getName() + "-->" + empObj.getSalary());
        }
        
    }
}
class Employee implements java.io.Serializable{
    private transient String name;
    // 加了transient的数据，则该数据不需要序列化
    private double salary;

    public Employee(){

    }

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }
}
```

### 序列化(Serializable)

1. 序列化就是将对象转换为字节序列的过程。
2. 序列化：把Java对象转换为字节序列的过程；
3. 反序列化：把字节序列恢复为Java对象的过程。
4. 对象序列化的作用：
   1. 持久化：把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中，比如：休眠地实现；以后服务器session管理，hibernate将对象持久化实现。
   2. 网络通信：在网络上传送对象的字节序列。比如：服务器之间的数据通信、对象传递。

#### 序列化涉及的类和接口

1. ObjectOutputStream代表对象输出流，它的writeObject(Object obj) 方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标流中。
2. ObjectInputStream代表对象输入流，他的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。
3. 只有实现了Serializable接口的类的对象才能被序列化。Serializable接口是一个空接口，只起到标记的作用。

### 转换流

1. `InputStreamReader/OutputStreamWriter` 用来将字节流转化成字符流。
2. 如：`System.in/System.out` 都是字节流对象，但是在我们的实际使用中就需要转换成字符流，所以我们就可以使用 `InputStreamReader/OutputStreamWriter` 来将字节流转化为字符流。

```java
import java.io.*;
public class Covert{
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
             BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));) {
            String msg = "";
            while (!msg.equals("exit")) {
                msg = reader.readLine();
                writer.write(msg);
                writer.newLine();
                writer.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

3. 也可以操作网络流来下载网络字节流，并且保存成字符。

```java
public static void main(String[] args) {
    // 操作网络流 下载百度的源代码
    try (BufferedReader reader =
                 new BufferedReader(
                         new InputStreamReader(
                                 new URL("http://www.baidu.com").openStream(),"UTF-8"));
         BufferedWriter writer =
                 new BufferedWriter(
                         new OutputStreamWriter(
                                 new FileOutputStream("beidu.html"),"UTF-8"));) {
        String msg = "";
        while ((msg = reader.readLine()) != null) {
            //System.out.println(msg);
            writer.write(msg);
            // 出现乱码，字符集不统一
            writer.newLine();
        }
        writer.flush();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

### 装饰器

1. 装饰器就是将一个功能更加强化。
2.  它可以实现对原有类的包装和装饰，使新的类具有更强的功能。 
3. 在IO流中大量使用了装饰器模式，让流具有更强的功能、更强的灵活性。
4. 用BufferedInputStream装饰了原有的FileInputStream，让普通的FileInputStream也具备了缓存功能，提高了效率。
5. 装饰器就是将原来的方法每继承一次重写一次或者重新写一个新的方法（这个方法继承父类的某个方法），使得子类的功能更加niubi.

### Apache

1. Apache-commons工具包提供了IOUtils/FileUtils，可以让我们非常的对文件和目录进行操作。
2. `IOUtils/FileUtils` 是我们上面IO文件和目录操作的封装。
3. Apache 软件基金会（Apache Software Foundation，简称ASF），官网地址：[www.apache.org](www.apache.org)
4. Apache由很多开源项目：commons,maven,hadoop。
5. [apache commons工具类简介]( https://www.iteye.com/blog/825635381-2230580 )

#### FileUtils类

```txt
cleanFirectory: 清空目录，但不删除目录。
contentEquals: 比较来给两个文件的内容是否相同
copyDirectory: 将一个目录内容拷贝到另一个目录。可以通过FileFilter过滤需要拷贝的文件.
copyFile：将一个文件拷贝到一个新的地址。
copyFileToDirectory：将一个文件拷贝到某个目录下。
copyInputStreamToFile：将一个输入流中的内容拷贝到某个文件。
deleteDirectory：删除目录。
deleteQuietly：删除文件。
listFiles：列出指定目录下的所有文件。
openInputSteam：打开指定文件的输入流。
readFileToString：将文件内容作为字符串返回。
readLines：将文件内容按行返回到一个字符串数组中。
sizeOf：返回文件或目录的大小。
write：将字符串内容直接写到文件中。
writeByteArrayToFile:将字节数组内容写到文件中。
writeLines：将容器中的元素的toString方法返回的内容依次写入文件中。
writeStringToFile：将字符串内容写到文件中。
```

```java
public class CFileUtils {
    public static void main(String[] args) throws IOException {
        // 写出文件
        FileUtils.write(new File("happy.txt"),"danfkdsnafs\r\n","UTF-8",true);
        FileUtils.writeStringToFile(new File("happy.txt"),"danfkdsnafs","UTF-8",true);
        FileUtils.writeByteArrayToFile(new File("happy.txt"),"danfkdsnafs学习".getBytes(),true);

        // 写出文件
        List<String> datas = new ArrayList<String>();
        datas.add("码云");
        datas.add("马化腾");
        datas.add("弼马温");

        FileUtils.writeLines(new File("happy.txt"),datas,"-_______",true);
        // 拷贝URL内容
        String URL = "https://img.zcool.cn/community/0128be58d20fc3a801219c77e6ff8e.jpg@1280w_1l_2o_100sh.jpg";
        FileUtils.copyURLToFile(new URL(URL),new File("marvel.jpg"));
    }
}
```

#### IOUtils类

```txt
buffer方法：将传入的流进行包装，变成缓冲流。并可以通过参数指定缓冲大小。
closeQueitly方法：关闭流。
contentEquals方法：比较两个流中的内容是否一致。
copy方法：将输入流中的内容拷贝到输出流中，并可以指定字符编码。
copyLarge方法：将输入流中的内容拷贝到输出流中，适合大于2G内容的拷贝。
lineIterator方法：返回可以迭代每一行内容的迭代器。
read方法：将输入流中的部分内容读入到字节数组中。
readFully方法：将输入流中的所有内容读入到字节数组中。
readLine方法：读入输入流内容中的一行。
toBufferedInputStream，toBufferedReader：将输入转为带缓存的输入流。
toByteArray，toCharArray：将输入流的内容转为字节数组、字符数组。
toString：将输入流或数组中的内容转化为字符串。
write方法：向流里面写入内容。
writeLine方法：向流里面写入一行内容。
```

```java
public class CIOUtils {
    public static void main(String[] args) throws IOException {

        //读取URL内容到字符串（百度是UTF-8，163是GBK）
        String datas = IOUtils.toString(new URL("https://www.163.com"),"GBK");
        System.out.println(datas);
    }
}
```

### Java中构建jar包

> File --> Project Structure --> Dependencies --> 添加相应的jar包然后Apply

